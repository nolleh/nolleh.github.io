<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Computer Programmer, Nolleh</title>
    <link>https://nolleh.github.io/</link>
    <description>Recent content on The Computer Programmer, Nolleh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>nolleh7707@gmail.com (nolleh)</managingEditor>
    <webMaster>nolleh7707@gmail.com (nolleh)</webMaster>
    <lastBuildDate>Tue, 01 Jan 2019 17:10:57 +0900</lastBuildDate>
    
	<atom:link href="https://nolleh.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>EOSIO - 1.6/개발 Wallet 생성하기</title>
      <link>https://nolleh.github.io/block-chain/1.6-createdevelopmentwallet/</link>
      <pubDate>Tue, 01 Jan 2019 17:10:57 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/block-chain/1.6-createdevelopmentwallet/</guid>
      <description>Step 1: Wallet 생성하기 먼저 wallet 을 생성한다. cleos wallet create 를 통해 기본 wallet 을 --to-console 옵션을 사용하여 간단하게 생성한다.
cleos 를 production 환경에서 사용한다면, 대신 --to-file 옵션을 사용하여 wallet 의 패스워드를 배쉬 기록에 남지않도록 한다.
개발 목적으로 사용하는 production 환경의 키가 아니기때문에 &amp;ndash;to-console 으로 보안 위협없이 사용할 수 있다.
cleos wallet create --to-console  cleos 는 패스워드를 반환하며, 이 패스워드를 다음 튜토리얼에서 이용할 수 있도록 저장하자.
Creating wallet: default Save password to use in the future to unlock this wallet.</description>
    </item>
    
    <item>
      <title>EOSIO - 1.5/CDT 설치하기</title>
      <link>https://nolleh.github.io/block-chain/1.5-installthecdt/</link>
      <pubDate>Tue, 01 Jan 2019 16:57:50 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/block-chain/1.5-installthecdt/</guid>
      <description>다음에서 발췌 - EOSIO - 1.5 Install The CDT
 EOSIO Contract Development Toolkit, CDT 는 contract 컴파일을 위한 툴의 집합이다. 뒤따를 튜토리얼들은 contract 들을 컴파일하고 ABI 를 생성하는 주요 CDT 를 사용한다.
1.3.x 버전부터, CDT 는 Mac OS X brew, linux debian 과 RPM 패키지들을 지원한다. 설치하기 위한 가장쉬운 선택지는 이 패키지 시스템들을 이용하는 것이다. 하나의 방법을 선택하자.
HomeBrew (Mac OS X) Install brew tap eosio/eosio.cdt brew install eosio.</description>
    </item>
    
    <item>
      <title>EOSIO - 1.4/노드 시작하고 설정하기</title>
      <link>https://nolleh.github.io/block-chain/1.4-startyournodeandsetup/</link>
      <pubDate>Tue, 01 Jan 2019 16:36:28 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/block-chain/1.4-startyournodeandsetup/</guid>
      <description>다음에서 발췌 - [](https://developers.eos.io/eosio-home/docs/getting-the-software)
 Step 1: Boot Node And Wallet Step 1.1: Start keosd 먼저 keosd 를 시작한다.
keosd &amp;amp;  다음과 유사한 결과를 얻게 된다.
info 2018-11-26T06:54:24.789 thread-0 wallet_plugin.cpp:42 plugin_initialize ] initializing wallet plugin info 2018-11-26T06:54:24.795 thread-0 http_plugin.cpp:554 add_handler ] add api url: /v1/keosd/stop info 2018-11-26T06:54:24.796 thread-0 wallet_api_plugin.cpp:73 plugin_startup ] starting wallet_api_plugin info 2018-11-26T06:54:24.796 thread-0 http_plugin.cpp:554 add_handler ] add api url: /v1/wallet/create info 2018-11-26T06:54:24.796 thread-0 http_plugin.cpp:554 add_handler ] add api url: /v1/wallet/create_key info 2018-11-26T06:54:24.</description>
    </item>
    
    <item>
      <title>EOSIO - 1.3/스택에 대해</title>
      <link>https://nolleh.github.io/block-chain/1.3-aboutthestack/</link>
      <pubDate>Tue, 01 Jan 2019 15:56:51 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/block-chain/1.3-aboutthestack/</guid>
      <description>발췌 - EOSIO - 1.3 About The Stack
 방금 설치한 툴들을 시작하기 전에, 각각의 컴포넌트들이 어떻게 상호작용하는지 이해하는게 좋다.
 nodeos (node + eos = nodeos) - 노드를 실행하기 위한 플러그인들로 설정될 수 있는 Core EOSIO 데몬. 예제는 로컬개발과 API 종단점을 위해 블록제품을 사용한다.
 cleos (cli + eos = cleos) - 블록 체인과 상호작용하고 wallet 을 관리하기위한 커맨드 라인 인터페이스.
 keosd (key + eos = keosd) - wallet 안의 EOSIO key 를 안전하게 저장 하기 위한 컴포넌트</description>
    </item>
    
    <item>
      <title>EOSIO - 1.2/시작하기 전에</title>
      <link>https://nolleh.github.io/block-chain/1.2-beforeyoubegin/</link>
      <pubDate>Tue, 01 Jan 2019 15:27:37 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/block-chain/1.2-beforeyoubegin/</guid>
      <description>발췌 - (EOSIO - 1.2 Before You Begin)[https://developers.eos.io/eosio-home/docs/setting-up-your-environment]
 Step 1: Install Binaries 이 튜토리얼은 선빌드된 바이너리를 사용한다.
가장 빨리 시작하는 방법은 이게 가장 좋은 선택지 일것이다. 소스로부터 빌드하는 것도 하나의 선택지이지만, 한시간 이상 걸릴 수 도 있으며 빌드 에러가 발생 할 수도 있다.
아래의 명령어들이 각각의 OS 에서 바이너리를 다운로드 할 것이다.
brew tap eosio/eosio brew install eosio  Step 2: Setup a development directory, stick to it 작업을 진행할 디렉토리를 선택할 필요가 있다.</description>
    </item>
    
    <item>
      <title>EOSIO - 1.1/소개</title>
      <link>https://nolleh.github.io/block-chain/1.1-introduction/</link>
      <pubDate>Tue, 01 Jan 2019 14:41:42 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/block-chain/1.1-introduction/</guid>
      <description>발췌 EOSIO - 1.1 Introduction
 배울 수 있는 것  노드로 얼마나 빨리 갖고 놀 수 있는가 Wallet 과 Key 를 어떻게 관리할 수 있는가 계정을 만드는 법 contract 작성법 컴파일과 ABI contract 배포  C / C++ 경험 EOSIO 기반 블록체인은 WebAssembly 를 이용하여 유저가 생성한 어플리케이션과 코드를 실행한다.
WASM 은 구글, 마이크로소프트, 애플, 그리고 다른 주요 업체의 지원을 받는 떠오르는 웹 표준이다.
오늘날 WASM 을 빌드하기위해 사용되는 성숙된 도구는 C/C++ 컴파일러를 통한 clang/llvm 이다.</description>
    </item>
    
    <item>
      <title>비동기 프로그램의 제어 흐름</title>
      <link>https://nolleh.github.io/csharp/async-control-flow-msdn/</link>
      <pubDate>Fri, 21 Dec 2018 22:02:13 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/csharp/async-control-flow-msdn/</guid>
      <description>개요  다음에서 발췌
비동기 프로그램의 제어 흐름
 코드 public partial class MainWindow : Window { // . . . private async void startButton_Click(object sender, RoutedEventArgs e) { // ONE Task&amp;lt;int&amp;gt; getLengthTask = AccessTheWebAsync(); // FOUR int contentLength = await getLengthTask; // SIX resultsTextBox.Text += $&amp;quot;\r\nLength of the downloaded string: {contentLength}.\r\n&amp;quot;; } async Task&amp;lt;int&amp;gt; AccessTheWebAsync() { // TWO HttpClient client = new HttpClient(); Task&amp;lt;string&amp;gt; getStringTask = client.GetStringAsync(&amp;quot;https://msdn.microsoft.com&amp;quot;); // THREE string urlContents = await getStringTask; // FIVE return urlContents.</description>
    </item>
    
    <item>
      <title>Async Await 을 사용한 비동기 프로그래밍</title>
      <link>https://nolleh.github.io/csharp/async-await-msdn/</link>
      <pubDate>Fri, 21 Dec 2018 21:41:08 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/csharp/async-await-msdn/</guid>
      <description>개요  다음에서 발췌 MSDN
 반응성을 향상시키는 비동기 잠재적인 차단 작업 완료 될때까지 다른 작업을 게속 수행
작성이 간편한 비동기 메서드 반환 형식은 다음 중 하나
- Task
- Task
- void - 비동기 이벤트 처리기 작성
- GetAwaiter 포함 모든 기타 형식
 await 을 만나면 yield 함 (호출자로 제어가 돌아감)
 이때, Task 가 호출자에게 반환되고 이는 언젠가 다운로드된 문자열의 길이가 반환된다는 약속 (future) 을 의미한다.</description>
    </item>
    
    <item>
      <title>Async Await</title>
      <link>https://nolleh.github.io/csharp/async-await/</link>
      <pubDate>Tue, 18 Dec 2018 13:47:33 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/csharp/async-await/</guid>
      <description>NeoSmart.AsyncLock 라이브러리에 관하여  다음에서 발췌, 번역 - Neosmart Docs.
 개요 semaporeslim 은 reentrance 를 지원하지 않는다. 따라서, recursion 에서 적절히 사용되지 않으면 데드락이 발생한다.
asynclock 은 reentrance 기능을 semaphoreslim 에 추가한거.
대안 간단한 방법은 semaphoreslim 으로 교체하고, recursion 인 경우를 스레드 아이디로 확인 하는 것.
이 경우의 문제는
async / await 의 가장 기본적인 목적인 ui 의 불필요한 블럭킹 없이 작업의 완료를 기다린다는 문제를 그대로 안고 있다.</description>
    </item>
    
    <item>
      <title>Nancy Introduction</title>
      <link>https://nolleh.github.io/nancy/introduction/</link>
      <pubDate>Tue, 24 Apr 2018 21:43:04 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/nancy/introduction/</guid>
      <description>Nancy 에 대한 문서 번역 #1. By Nolleh
 Introduction 가장 먼저, Nancy 의 세계에 온것을 환영합니다!
루비의 sinatra 프레임워크에 영감을 받아 Nancy 라는 이름을 붙이게 되었습니다. (Frank Sinatra 의 딸이름이 Nancy 니까요!)
NancyFx 의 Fx 에 대해 많은 사람들이 궁금해하여 여기에 붙입니다만, framework 라는 뜻입니다 :)
NancyFx 는 모든 컴포넌트들을 포함하는 umbrella project 입니다. (#역자주: 우산효과의 우산처럼, 포괄적인 프로젝트라는 의미로 쓴게 아닐까? )
이 가이드는 앞으로 개괄적이고 빠르게 Nancy 의 특징들을 살펴 독자 스스로 Nancy 의 세계를 탐험해 볼 수 있는 시야를 제공할겁니다.</description>
    </item>
    
    <item>
      <title>Unix 01 Intro</title>
      <link>https://nolleh.github.io/post/unix-01-intro/</link>
      <pubDate>Tue, 01 Aug 2017 22:54:19 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/unix-01-intro/</guid>
      <description>네트워킹의 바이블이라 할 수 있는 Unix Network Programming 의 내용 정리
 Books Introduction Socket 을 통해 통신하는 프로그램을 작성하는 개발자를 위해 쓰여진 책.
시작하는 사람에게나, 프로페셔널에게나 유용한 책.
물론 유지보수를 하거나, 새로 작성하는 사람, 네트워크 시스템 함수를 이해하는 모두에게 유용하다.
실제 텍스트들은 유닉스 시스템에서 구동가능하나, OS 에 독립적인 socket api 를 지원하는 다른 OS 에서도, 본문에서 제안하는 일반적인 개념을 활용가능하다.
많은 OS 는 셀수 없이 많은 네트워크 응용프로그램을 제공하고 있으며 - 예컨데 웹브라우저, email.</description>
    </item>
    
    <item>
      <title>스프링 기본 용어/정리</title>
      <link>https://nolleh.github.io/post/fund-spring/</link>
      <pubDate>Wed, 26 Jul 2017 23:11:14 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/fund-spring/</guid>
      <description>어쩌다보니 그동안 손댈 일이 없던 웹서버에 좀 손을 대게 되서 (게임서버, 클라이언트, 그리고 웹서버..정녕 풀스택 개발자가 되는것인가..ㅋ), 예전 선배님이 버리고 간(?) 스프링 책을 꺼내서 읽어 보며 정리한 내용이므로 본 글을 처음 접한 사람이 이해하기에 많은 내용을 담지 않을 수 있음.
 Spring Bean 객체 스프링에서 생성하여 관리하여 주는 스프링 빈 객체 혹은 빈 객체라고 부른다. res/applicationContext.xml 에  태그로 선언할 수도 있다. 이렇게 선언한경우, 리플렉션을 활용하여 bean id 클래스의 인스턴스를 지정한 세부 태그의 속성으로 메서드를 호출하여 객체를 초기화한다.</description>
    </item>
    
    <item>
      <title>파일 버퍼링</title>
      <link>https://nolleh.github.io/post/file-buffering/</link>
      <pubDate>Mon, 17 Jul 2017 00:25:28 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/file-buffering/</guid>
      <description>다음에서 발췌, 번역
- https://msdn.microsoft.com/en-gb/library/windows/desktop/cc644950(v=vs.85).aspx
 File Buffering 파일버퍼링 - unbuffered file I/O.
본문에선 시스템에 의해 캐싱되지 않는 (buffered) 데이터를
어떻게 유저 모드의 응용프로그램에서 데이터를 활용할 수 (interact) 있을지에 대해 다룬다.
FILE_FLAG_NO_BUFFERING 플래그를 통해 CreateFile 을 Open 하면,
파일을 읽거나 쓸때 시스템의 캐싱을 비활성화 하도록 제어할 수 있다.
I/O 버퍼링을 사용한것과 같은 효과를 내려면, 데이터 alignment 가 반드시 고려되어야 한다.
Note 파일에 대해 Seeking 과 위치포인터, offsets 의 개념을 사용하는 파일에 대해 alignment 정보가 고려될 필요가 있다.</description>
    </item>
    
    <item>
      <title>Concurrent Idiom 1 - Stack</title>
      <link>https://nolleh.github.io/post/concurrent-idiom-1-stack/</link>
      <pubDate>Mon, 10 Jul 2017 22:57:57 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/concurrent-idiom-1-stack/</guid>
      <description>concurrent 프로그램을 작성할 때 고려해야할 몇가지 사항. 그리고 idiom.
여러 서적에서 발췌하였으며, 정리 차원에서 작성한 내용이므로 본 글을 처음 접한 사람이 이해하기에 많은 내용을 담지 않을 수 있음.
어쩌면 작성자의 부사수를 위한 자재가 될지도 모르겠&amp;hellip;(..)
 Concurrent ISSUE - Stack 이번엔 스택.
if (!s.empty()) { item = s.top(); s.pop(); }  인터페이스상의 문제이기 때문에 empty 와 top 사이의 safety 를 보장할 수 없다.
top() / pop() 도 마찬가지 -&amp;gt;&amp;gt; 조회되지 못하는 아이템이 있을 수 있다.</description>
    </item>
    
    <item>
      <title>How To Make Git Page</title>
      <link>https://nolleh.github.io/post/how-to-make-git-page/</link>
      <pubDate>Fri, 07 Jul 2017 21:22:50 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/how-to-make-git-page/</guid>
      <description>GitHub-Page 이런게 있다더라 ~ 라고 주변으로부터 처음 들은건 1~2년전이었던것 같은데
갑자기 꽂혀서 git page 를 만들었다. (!!)
github 에서는 1계정당 1 호스트를 제공하는 것 같고
뭐 이런식? github 의 제공 영역은 repo 에 존재하는 index.html 을 repo 에 지정된 1 도메인과 연결해주는 정도인 것 같다. # Repository git 을 사용해 본 적이 있다면 간단하다. 그렇다면 다음 절로 넘어가고, 그렇지 않다면, 다음을 따라하자. ## github 가입 이 항목에 있어 더 이상의 자세한 설명은 생략한다.</description>
    </item>
    
    <item>
      <title>Brew Install 이 구버전만 설치할 때</title>
      <link>https://nolleh.github.io/post/brew-update/</link>
      <pubDate>Tue, 04 Jul 2017 22:31:23 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/brew-update/</guid>
      <description>Let&amp;rsquo;s 사족 처음 회사에 입사 했을 때 자리에는 Mac PC 만이 덩그러니 있었고, Mac 을 사용해본적 없던 꼬꼬마는 자연스럽게 윈도우 CD 를 인사팀에서 받아와서 깔고 있었드랬다.
 &amp;ldquo;기껏 좋은 컴퓨터 줬더니 넌 뭘하고 있는거니?&amp;rdquo;
 라는 선배의 말을 듣고 그제야 맥에서도 안드로이드 개발이 되는거구나.. (이때는 현업 안드로이드 개발자였다.)
하곤 윈도우 설치페이지를 취소하고 다시 맥 OS 를 부팅했었지.
이때가, Mac OS 와의 첫 만남이었드랬다.
Brew 뭐 전혀 관계 없는 얘기로 포스트를 열었지만.</description>
    </item>
    
    <item>
      <title>markDown 문법</title>
      <link>https://nolleh.github.io/post/mark-down-syntax/</link>
      <pubDate>Tue, 04 Jul 2017 22:13:52 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/mark-down-syntax/</guid>
      <description>마크다운으로 포스팅하는 Git 페이지를 생성하였으니, 자주 사용되는 대표 문법 정리
마크다운 문법
Heading &amp;rsquo;#&amp;rsquo; 으로 처리하며, 단계별로 더 많은 &amp;lsquo;#&amp;rsquo; 을 사용한다.
# Title ## Heading 1 ### Heading 2  결과
Title Heading 1 Heading 2 Listing Asterisk (*) 를 사용하여 순서 없는 목록을, 숫자를 사용하여 순서 있는 목록을 나타낸다.
순서 없는 경우  이거닷
 이거 중요해!
  순서가 있는 경우  첫번째 순서 두번째~ 셋!!  Fonts **Bold** _Italic_ ~~CANCEL_LINE~~  Bold Italic CANCEL_LINE</description>
    </item>
    
    <item>
      <title>C&#43;&#43;/CLI 에서 managed 콜백을 unmanaged 로 전달하기</title>
      <link>https://nolleh.github.io/post/managed_cb_to_unmanaged/</link>
      <pubDate>Tue, 04 Jul 2017 00:45:55 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/managed_cb_to_unmanaged/</guid>
      <description>파라미터가 없다면 DelegateToPointer 로 마샬링해서 전달하면되는데,
이러면 파라미터를 마샬링할 기회가 주어지지 않는다는게 문제다.
좀 구글링을 해봤는데,
이런 포스트가 있었다.
스택오버플로-파라미터와 함께 unmanaged 콜백으로 변환하기
채택된 답변을 살펴보면 클래스 구조는 대략 다음과 같다.
클래스 구조   NativeCallbackHandler - msclr::gcroot m_owner (OutputLogManaged) 를 멤버로 보유.
 OutputLogManaged - native OutputLog* (m_nativeOutputLog) / 1의 Holder 를 보유 (m_nativeHandler)] / 그리고 managed 콜백을 보유
 OutputLog - Native Callback 과 void* UserData 를 멤버로 보유.</description>
    </item>
    
    <item>
      <title>Hello, Git Pages!</title>
      <link>https://nolleh.github.io/post/good-to-great/</link>
      <pubDate>Mon, 03 Jul 2017 23:44:54 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/post/good-to-great/</guid>
      <description>Hello World!</description>
    </item>
    
  </channel>
</rss>