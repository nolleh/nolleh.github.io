<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>The Computer Programmer, Nolleh</title>
    <link>https://nolleh.github.io/</link>
    <description>Recent content on The Computer Programmer, Nolleh</description>
    <generator>Hugo -- 0.123.7</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 22 May 2024 21:37:29 +0900</lastBuildDate>
    <atom:link href="https://nolleh.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.basics</title>
      <link>https://nolleh.github.io/zeromq/1.basics/</link>
      <pubDate>Wed, 22 May 2024 21:37:29 +0900</pubDate>
      <guid>https://nolleh.github.io/zeromq/1.basics/</guid>
      <description>다음 번역 Chapter 1 - Basics Fixing The World 프로그래밍의 물리요, 과학은: 사람들이 쉽게 이해하고 사용할 수 있는 빌딩블록을 만들고 함께 큰 문제를 해결하는 데에 있다.
우리는 연결되어 있는 세상에 살고 있고 현대의 소프트웨어는 세상을 안내한다.
하지만 데이터와 지식들은 클라우드와 개인 컴퓨터에 존재하고 인터넷은 &amp;lsquo;연결된&amp;rsquo; 코드의 잠재성을 제안했지만
현실은 많은 흥미로운 문제들(건강/교육/경제/..)이 코드를 &amp;lsquo;연결&amp;rsquo; 할 방법이 없기 때문에 많은 지식(brain) 을 연결하지 못해 해결되지 못한 채로 남아있다.
IETF 표준들과같은 많은 노력으로 코드를 연결하기 위한 시도들이 행해졌다.</description>
    </item>
    <item>
      <title>struggles to view OTT on UBUNTU X raspberry Pi 5 - A.K.A using Widevinecdm</title>
      <link>https://nolleh.github.io/ubuntu/widevinecdm/</link>
      <pubDate>Sun, 25 Feb 2024 16:59:57 +0900</pubDate>
      <guid>https://nolleh.github.io/ubuntu/widevinecdm/</guid>
      <description>라즈베리파이5 * Ubuntu 에서DRM 스트리밍서비스 (OTT) 를 이용하려고 여러 글들을 살펴봄.
https://github.com/brave/brave-browser/issues/28903
https://support.brave.com/hc/en-us/articles/23881756488717-How-do-I-enable-Widevine-DRM-on-Linux
https://forum.radxa.com/t/lets-get-widevine-working/15391
https://github.com/raspberrypi/Raspberry-Pi-OS-64bit/issues/248
음 다안된다. 구글에서 제공하는 widevinecdm 컴포넌트/라이브러리가 필요한 모양인데 대략 해석해보면 구글에서 공식적으로 지원하는 aacrch 용은 없는 모양이고 일부 오픈소스에서 chrome OS 용으로 제공하는 python 스크립트로 라이브러리를 좀 변조하는 형태로 시도한 내용들이 보이는데
vivaldi 브라우저에서 컴포턴트가 드디어 노출되는건 확인했지만
해당 라이브러리가 정상적으로 동작하지는 않는모양.
그냥 라즈베리파이에서는 공식 제공하는 라즈비안OS 를 사용하는 게 그냥 마음 편할듯.
다만 난 우분투를 계속 가지고 놀 작정이라 일단 OTT 는 그냥 포기해야하겠다.</description>
    </item>
    <item>
      <title>5.securing the Boot Procss and Hardware Resources</title>
      <link>https://nolleh.github.io/linux/18.local-security-principles/5.securing-the-boot-procss-and-hardware-resources/</link>
      <pubDate>Sun, 07 Jan 2024 12:55:07 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/18.local-security-principles/5.securing-the-boot-procss-and-hardware-resources/</guid>
      <description>Requiring Boot Loader Passwords You can secure the boot process with a secure epassword to prevent someone from bypassing the user authentication step. This can work in conjunction with password protection for the BIOS. Note that while using a bootloader passwrd laone will stop a user from editing the bootloader configuration during the boot process, it will not prevent a user from booting from and alterantive boot media such as optical disks or pen drives.</description>
    </item>
    <item>
      <title>4.working With Passwords</title>
      <link>https://nolleh.github.io/linux/18.local-security-principles/4.working-with-passwords/</link>
      <pubDate>Sun, 07 Jan 2024 12:41:06 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/18.local-security-principles/4.working-with-passwords/</guid>
      <description>How Passwords Are Stored The system verifies authenticity and identity using user credentials.
Originally, encrypted passwords wer stored in the /etc/passwd file, which was readable by everyone. this mde it rather easy for passwords to be craked.
On modern systems. passwords are actually stored in an encrypted format in a secondary file named etc/shadow Onyly those with root access can read or modify this file.
Password Encrpytion Protecting passwords has became a curucial element of security.</description>
    </item>
    <item>
      <title>3.sudo Process Isolation Limiting Hardware Access and Keeping Systems Current</title>
      <link>https://nolleh.github.io/linux/18.local-security-principles/3.sudo-process-isolation-limiting-hardware-access-and-keeping-systems-current/</link>
      <pubDate>Sun, 07 Jan 2024 12:11:04 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/18.local-security-principles/3.sudo-process-isolation-limiting-hardware-access-and-keeping-systems-current/</guid>
      <description>The sudoers File /etc/sudoers contains a lot of documentation in it about how to customize. Most Linux distributions now prefer you add a file in the directory etc/sudoers.d with a name the same as user.
this file contains the individual user&amp;rsquo;s sudo configuration, and one should leave the main configuration file untouched except for changeds that affect that affect all users.
sudo commands and any failures are logged in &amp;hellip;</description>
    </item>
    <item>
      <title>2.understanding Linux Security</title>
      <link>https://nolleh.github.io/linux/18.local-security-principles/2.understanding-linux-security/</link>
      <pubDate>Sat, 06 Jan 2024 16:26:12 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/18.local-security-principles/2.understanding-linux-security/</guid>
      <description>User Accounts Linux kernel authenticated users to access files and applications. while each user is identified by a unique integer (the user id or UID), a separate database associates a username with each UID.
Types of Accounts By default, Linux distinguishes between several account types in order to isolate processes and workloads.
Linux has fourtypes of accounts:
root System Normal Network For a safe working env, it is advised to grant minimum privileges possible and necessary to accounts, and remove inactive accounts.</description>
    </item>
    <item>
      <title>4.manipulating Postscript and Pdf Files</title>
      <link>https://nolleh.github.io/linux/17.printing/4.manipulating-postscript-and-pdf-files/</link>
      <pubDate>Sat, 06 Jan 2024 14:42:02 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/17.printing/4.manipulating-postscript-and-pdf-files/</guid>
      <description>Working with PostScript and PDF PostScript is a standard page description language. it effectively manages scalilng of fonts and vector graphics to provide quality printouts.
The format itself is a language that Adobe developed in the early 1980s to enable the transfer of data to printers.
Feature of PostScript are:
it can be used on any printer that is PostScript-compatible, i.e., any modern printer. Any program that understands the PostScript specification can print to it.</description>
    </item>
    <item>
      <title>2.configuration</title>
      <link>https://nolleh.github.io/linux/17.printing/2.configuration/</link>
      <pubDate>Fri, 05 Jan 2024 22:23:34 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/17.printing/2.configuration/</guid>
      <description>Printing on Linux printing itself requires software that converts information from application you are using to a language your printer can understand.
The Linux standard for printing software is the Common UNIX Printing System (CUPS)
Modern Linux desktop systems make installing and administering printers simple and intuitive.
Nevertheless, it is instructive to understand the underpinnings of how it is done in Linux.
CUPS Overview CUPS interprets page descriptions produced by your application (put a paragraph here, draw a line there, and so forth) and then sends the information to the printer.</description>
    </item>
    <item>
      <title>Some Additional Useful Techniques</title>
      <link>https://nolleh.github.io/linux/16.more-on-bash-shell-scripting/some-additional-useful-techniques/</link>
      <pubDate>Thu, 04 Jan 2024 21:38:12 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/16.more-on-bash-shell-scripting/some-additional-useful-techniques/</guid>
      <description>$RANDOM: environment variable for
performing security-related tasks Reinitializing storage devices Erasing and/or obscuring existing data Generating meaningless data to be used for tests How the Kernel Generates Random Numbers Some servers have hardware random number generators that take as input different types of noise signals, such as thermal noise and photoelectric effect. A transducer converts this noise into an electric signal, which is again converted into a digital number by an A-D converter.</description>
    </item>
    <item>
      <title>3.syntax</title>
      <link>https://nolleh.github.io/linux/15.the-bash-shell-and-basic-scripting/3.syntax/</link>
      <pubDate>Tue, 26 Dec 2023 22:19:46 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/15.the-bash-shell-and-basic-scripting/3.syntax/</guid>
      <description>Basic Syntax and Special Characters Character Description # comment, shebang, # \ nextline, escapecode ; used to interpret what follows as a new command to be executed $ environment variable &amp;gt; redirect output &amp;raquo; Append output &amp;lt; Redirect input | pipe the result into next command Putting Multiple Commands on a Single Line # run consequent command whether or not preceding one succeeded. $ make ; make install ; make clean # proceed next command only when preceding one succeeded.</description>
    </item>
    <item>
      <title>2.features and Capabilities</title>
      <link>https://nolleh.github.io/linux/15.the-bash-shell-and-basic-scripting/2.features-and-capabilities/</link>
      <pubDate>Mon, 25 Dec 2023 23:17:13 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/15.the-bash-shell-and-basic-scripting/2.features-and-capabilities/</guid>
      <description>script&amp;rsquo;s return value is stored in the environment variable represented by $?:
echo $? </description>
    </item>
    <item>
      <title>1.introduction</title>
      <link>https://nolleh.github.io/linux/15.the-bash-shell-and-basic-scripting/1.introduction/</link>
      <pubDate>Mon, 25 Dec 2023 22:57:05 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/15.the-bash-shell-and-basic-scripting/1.introduction/</guid>
      <description> Explain the features and capabilities of bash shell scripting. Know the basic syntax of scripting statements. Be famailiar with various methods and constructs used. Test for properties and existence of files and other objects. Use conditional statements, such as if-then-else blocks. Perform arithmetic operations using scripting language. </description>
    </item>
    <item>
      <title>5.transferring Files</title>
      <link>https://nolleh.github.io/linux/14.network-operations/5.transferring-files/</link>
      <pubDate>Mon, 25 Dec 2023 21:54:44 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/14.network-operations/5.transferring-files/</guid>
      <description>FTP (File Transfer Protocol) FTP is a well-known and popular method for transferring files between computers using the internet. This method is built on a client-server model.
one of the oldest method of network data transfer, dating back to the early 1970s. As such, it is considered inadequate for modern needs, as well as begin intrinsically insecure. However, it is still in use and when security is not a concern (such as with so-called anonymous FTP) it can make sense.</description>
    </item>
    <item>
      <title>4.browsers Wget and Curl</title>
      <link>https://nolleh.github.io/linux/14.network-operations/4.browsers-wget-and-curl/</link>
      <pubDate>Mon, 25 Dec 2023 21:47:59 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/14.network-operations/4.browsers-wget-and-curl/</guid>
      <description>wget Large file downloads Recursive downloads, where a web page refers to other web pages and all are downloaded at once Password-required downloads Multiple file downloads curl Besides downloading, you may want to obtain information about a URL, such as the source code being used. curl can be used from the command line or a script to read such information.</description>
    </item>
    <item>
      <title>3.networking Configuration and Tools</title>
      <link>https://nolleh.github.io/linux/14.network-operations/3.networking-configuration-and-tools/</link>
      <pubDate>Mon, 25 Dec 2023 21:26:56 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/14.network-operations/3.networking-configuration-and-tools/</guid>
      <description>more networking tools ethtool
Queries network interfaces and can also set various parameters such as the speed netstat
option r is for active connection nmap
scans open ports on a networks; important for security analysis tcpdump
dumps network traffic for anaysis iptraf
monitors network traffic in text mode mtr
combines functionality of ping and traceroute and gives a continuously updated display dig
Tests DNS workings;a good replacement for host and nslookup </description>
    </item>
    <item>
      <title>2.introduction to Networking</title>
      <link>https://nolleh.github.io/linux/14.network-operations/2.network-addresses-and-dns/</link>
      <pubDate>Mon, 25 Dec 2023 18:10:12 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/14.network-operations/2.network-addresses-and-dns/</guid>
      <description>IPv4 and IPv6 IPv4 uses 32-bits for addresses;there are only 4.3 bilion unique addresses available.
IPv6 uses 128-bits for addresses; this allows for 3.4 * 10^38 unique addresses.
One reason IPv4 has not disappeared is there are widely-used ways t o effectively make many more addresses available by methods such as NAT(Network Address Translation). NAT enables sharing one IP address among many locally connected computers, each of which has a unique address only seen on the local network.</description>
    </item>
    <item>
      <title>1.introduction</title>
      <link>https://nolleh.github.io/linux/14.network-operations/1.introduction/</link>
      <pubDate>Mon, 25 Dec 2023 18:07:03 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/14.network-operations/1.introduction/</guid>
      <description> Explain basic networking concepts, including types of networks and addressing issues. Configure network interfaces and use basic networking utilities, such as ifconfig, ip, ping, route and traceroute Use grphical and non-graphical browsers, such as Lynx, w3m, Firefox, Chrome and Epiphany. Transfer files to and from clients and servers using both graphical and text mode applications, such as scp, ftp, sftp, curl and wget. </description>
    </item>
    <item>
      <title>7.miscellaneous Text Utilities</title>
      <link>https://nolleh.github.io/linux/13.manipluating-text/7.miscellaneous-text-utilities/</link>
      <pubDate>Mon, 25 Dec 2023 17:36:43 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/13.manipluating-text/7.miscellaneous-text-utilities/</guid>
      <description>tr the tr utility is used to translate specified characters into other characters or to delete them.
tr [options] set1 [set2] set1: to be replaced or removed set2: to be substituted for the characters listed in the first argument.
tr &amp;lsquo;{}&amp;rsquo; &amp;lsquo;()&amp;rsquo; &amp;lt; inputfile &amp;gt; outputfile
translate braces into parenthesis echo &amp;quot; &amp;hellip; &amp;quot; | tr [:space:] &amp;lsquo;\t&amp;rsquo;
translate white-space to tabs echo &amp;ldquo;This is for testing&amp;rdquo; | tr -s [:space:]</description>
    </item>
    <item>
      <title>6.grep</title>
      <link>https://nolleh.github.io/linux/13.manipluating-text/6.grep/</link>
      <pubDate>Mon, 25 Dec 2023 17:19:18 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/13.manipluating-text/6.grep/</guid>
      <description>grep grep [0-9] print the lines that contain the numbers 0 through 9 grep -C 3 [pattern] print context of lines (specified number of lines above and below the pattern) for matching the pattern. Here, the number of lines is specified as 3 strings strings is used to extract all character strings found in the file or files given as arguments. it is useful in locating human-readable content embedded in binary files; for text files one can just use grep</description>
    </item>
    <item>
      <title>5.file Manipulation Utilities</title>
      <link>https://nolleh.github.io/linux/13.manipluating-text/5.file-manipulation-utilities/</link>
      <pubDate>Mon, 25 Dec 2023 15:20:05 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/13.manipluating-text/5.file-manipulation-utilities/</guid>
      <description>sort sort -k 3 sort the lines by the 3rd field on each line instead of the beginning sort -u equivalent to run uniq after sort
uniq uniq removes duplicate consecutive lines in a text file and is useful for simplifying the text display uniq requires that the duplicate entries must be consecutive, one often runs sort first and then pipes the output into uniq;
to count the number of duplicate entries, use the following command:</description>
    </item>
    <item>
      <title>4.sed and Awk</title>
      <link>https://nolleh.github.io/linux/13.manipluating-text/4.sed-and-awk/</link>
      <pubDate>Mon, 25 Dec 2023 14:39:39 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/13.manipluating-text/4.sed-and-awk/</guid>
      <description>introduction to sed and awk many Linux users and administrators will write scripts using comprehensive scripting languages such as Python and perl,
rather than use sed and awk. However, the utilitites that are described here are much lighter;i.e. they use fewer system resources,
and execute faster.
sed abbreviation for stream editor.
data from an input source/file (or stream) is taken and moved to a working space.
the entire list of operations/modifications is applied over the data in the working space and</description>
    </item>
    <item>
      <title>3.working With Large and Compressed Files</title>
      <link>https://nolleh.github.io/linux/13.manipluating-text/3.working-with-large-and-compressed-files/</link>
      <pubDate>Mon, 25 Dec 2023 14:29:53 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/13.manipluating-text/3.working-with-large-and-compressed-files/</guid>
      <description>working with large files directly opening the file in an editor will probably be inefficient (due to high memory utilization) because most text editors usually try to read the whole file into memory first.
instead, one can use less to view the contents of such a large file, scrolling up and down page by page, without the system having to place the entire file in memory before starting.
less somefile cat somefile | less head reads the first few lines</description>
    </item>
    <item>
      <title>2.cat and Echo</title>
      <link>https://nolleh.github.io/linux/13.manipluating-text/2.cat-and-echo/</link>
      <pubDate>Mon, 25 Dec 2023 14:12:57 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/13.manipluating-text/2.cat-and-echo/</guid>
      <description>cat cat
read / write / concatenate tac prints the lines of a file in reverse order. each line remains the same, but the order of lines is inverted. cat &amp;gt; file cat &amp;raquo; file (any subsequenet lines are appended to the file, until CTRL-D is typed)
using cat interactively echo -e option, along with the following switches, is used to enable special character sequences,
such as the newline character or horizontal tab</description>
    </item>
    <item>
      <title>2.accounts,users and groups</title>
      <link>https://nolleh.github.io/linux/12.user-environment/2.accounts-users-and-groups/</link>
      <pubDate>Sun, 24 Dec 2023 18:05:04 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/12.user-environment/2.accounts-users-and-groups/</guid>
      <description>elevating to root account sudo configuration files are stored in the /tec/sudoers file and in the /etc/sudoers.d directory. by default, the sudoers.d directory is empty</description>
    </item>
    <item>
      <title>7.summary</title>
      <link>https://nolleh.github.io/linux/10.file-operations/7.summary/</link>
      <pubDate>Sun, 24 Dec 2023 16:46:33 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/10.file-operations/7.summary/</guid>
      <description>filesystems lick /proc are called pseudo filesystems because they exist only in memory
/var may be put in its own filesystem so that growth can be contained and not fatally affect the ststem
/boot contains the basic files needed to boot the system</description>
    </item>
    <item>
      <title>5.backing Up and Compressing Data</title>
      <link>https://nolleh.github.io/linux/10.file-operations/5.backing-up-and-compressing-data/</link>
      <pubDate>Sun, 24 Dec 2023 15:42:26 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/10.file-operations/5.backing-up-and-compressing-data/</guid>
      <description>1. Backing Up Data cp &amp;lt;-&amp;gt; rsync
rsync is more efficient, because it checks if the file being copied already exists. rsync copies only the parts of files that have actually changed, it can be very fast cp can only copy files to and from destinations on the local machine (unless mounted using NFS), rsync can also be used to copy files from one machine to another. someone@host:path 2. Using rsync a very useful way to back up a project directory might be to use the following command.</description>
    </item>
    <item>
      <title>4.comparing Files and File Types</title>
      <link>https://nolleh.github.io/linux/10.file-operations/4.comparing-files-and-file-types/</link>
      <pubDate>Sun, 24 Dec 2023 15:09:57 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/10.file-operations/4.comparing-files-and-file-types/</guid>
      <description>3. using the file utility in linux, a file&amp;rsquo;s extension does not, by default, ategorize its nature the way it might in other operating systems. for example, one cannot assume that a file named &amp;ldquo;file.txt&amp;rdquo; is a text file and not an executable program.
6. Lab10.2: Using diff and patch diff -Naur original modified &amp;gt; original.patch patch original &amp;lt; original.patch </description>
    </item>
    <item>
      <title>Searching For Files</title>
      <link>https://nolleh.github.io/linux/7.command-line-operations/searching-for-files/</link>
      <pubDate>Mon, 02 Oct 2023 19:56:54 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/7.command-line-operations/searching-for-files/</guid>
      <description>A special shorthand notation can send anything written to file descriptor 2 (stderr) to the same place as file descriptor 1 (stdout): 2&amp;gt;&amp;amp;1.
$ do_something &amp;gt; all-output-file 2&amp;gt;&amp;amp;1
bash permits an easier syntax for the above:
$ do_something &amp;gt;&amp;amp; all-output-file
in pipe&amp;hellip; $ command1 | command2 | command3
The above represents what we often call a pipeline, and allows Linux to combine the actions of several commands into one. This is extraordinarily efficient because command2 and command3 do not have to wait for the previous pipeline commands to complete before they can begin processing at the data in their input streams</description>
    </item>
    <item>
      <title>2.system Display Date and Time Settings</title>
      <link>https://nolleh.github.io/linux/5.system-configuration-from-the-graphical-interface/2.system-display-date-and-time-settings/</link>
      <pubDate>Sat, 30 Sep 2023 11:06:13 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/5.system-configuration-from-the-graphical-interface/2.system-display-date-and-time-settings/</guid>
      <description>the system actually provide display settings, is uses /etc/x11/xorg.conf
in recent linux, the file usually present in unusual cricumstatnce such as when cirtain Less
common graphic drivers are in use.
changing the file is usually for more advanced users.
Network Time Protocol the Network Time Protocol is most popular and reliable protocol for setting local time by consulting established internet servers.
student:/tmp&amp;gt; $ xdpyinfo | grep dim dimensions: 3200x1080 pixels (847x286 millimeters) </description>
    </item>
    <item>
      <title>1.learning Objectives</title>
      <link>https://nolleh.github.io/linux/5.system-configuration-from-the-graphical-interface/1.learning-objectives/</link>
      <pubDate>Sat, 09 Sep 2023 19:19:58 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/5.system-configuration-from-the-graphical-interface/1.learning-objectives/</guid>
      <description>apply system, display, timesetting.. track the network settings and manage connections using network manager in linux. install and update software in linux from a graphical interface.</description>
    </item>
    <item>
      <title>Optimize Speed</title>
      <link>https://nolleh.github.io/ubuntu/optimize-speed/</link>
      <pubDate>Sat, 09 Sep 2023 15:36:52 +0900</pubDate>
      <guid>https://nolleh.github.io/ubuntu/optimize-speed/</guid>
      <description>라즈베리파이에서 우분투를 설치해서 사용하고 있는데, 인터넷 속도가 어마하게 느린 이슈가 있다.
거기서 개선을 위해 시도해본 것들에 대해 기록할 예정.
##1. iwconfig
일단 다음은 확실히 효용이 있는 것으로 보임.
60mb -&amp;gt; 140mb 정도로 개선됨.
sudo iwconfig wlan0 power off ##2. zram
그리고나서, zswap 대신 zram 을 사용하도록 변경.
sudo apt install -y linux-modules-extra-raspi sudo apt install -y zram-tools sudo apt autoremove --purge -y zram-config sudo nvim /etc/default/zramswap 에디터는 어떤걸 사용해도 상관없지만, nvim 사용하고 있어서 그걸로 세팅.</description>
    </item>
    <item>
      <title>Neovim</title>
      <link>https://nolleh.github.io/ubuntu/neovim/</link>
      <pubDate>Sat, 09 Sep 2023 15:33:49 +0900</pubDate>
      <guid>https://nolleh.github.io/ubuntu/neovim/</guid>
      <description>apt-get install neovim 과 같은 방법으로는 최신 버전을 설치 할 수 없다.
최신버전을 설치하려면, 다음 과정을 거쳐야한다.
cf.https://github.com/neovim/neovim/wiki/Installing-Neovim
sudo apt-get install software-properties-common
이 명령어를 선행해줘야할 수도 있다. sudo apt-get remove neovim -y sudo add-apt-repository ppa:neovim-ppa/stable sudo apt-get update -y sudo apt-get install neovim -y https://launchpad.net/~neovim-ppa/+archive/ubuntu/unstable
ppa archive 를 살펴보고 원하는 아키텍쳐 / 버전이 없는경우 unstable 버전에서 찾아서 다시 반복해볼 필요가 있다. 다행히 unstable 버전은 ubuntu 23.04 를 지원하는게 있어서 받아서 씀&amp;hellip;</description>
    </item>
    <item>
      <title>Kblayout</title>
      <link>https://nolleh.github.io/ubuntu-set/kblayout/</link>
      <pubDate>Sat, 12 Aug 2023 17:26:22 +0900</pubDate>
      <guid>https://nolleh.github.io/ubuntu-set/kblayout/</guid>
      <description>/etc/default/keyboard
Option	&amp;ldquo;XkbModel&amp;rdquo;	&amp;ldquo;kr106&amp;rdquo; Option	&amp;ldquo;XkbLayout&amp;rdquo;	&amp;ldquo;kr&amp;rdquo;</description>
    </item>
    <item>
      <title>Diskutil</title>
      <link>https://nolleh.github.io/cli/diskutil/</link>
      <pubDate>Sat, 05 Aug 2023 16:14:33 +0900</pubDate>
      <guid>https://nolleh.github.io/cli/diskutil/</guid>
      <description>mac 에서는, diskutil 과 dd 를 사용해서 microSD 카드를(disk) 포멧 할 수 있다.
disk utility 라는 GUI 툴도 있는데, 파티셔닝 되어있던 애를 이걸 통해서 지웠더니 뭔갈 잘못한건지 절반정도의 디스크용량이 날아가 버렸다 ㅡㅡ;;;
32GB 짜리 SD 카드가 반토막 난 격이라;; dd 와 fdisk 를 활용해서 뭔가 다시 복구하려는 삽질기가 되시겠다&amp;hellip;
$ diskutil list output
/dev/disk5 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: *15.9 GB disk5 format 하려면
$ diskutil umount $ sudo dd if=/dev/zero of=/dev/{dev-name} bs=1M status=progress ## this is really long term work 되-게 오래 걸리는 작업이라서, 잊지 말고status=progress 옵션을 사용하는 것을 권장 한다.</description>
    </item>
    <item>
      <title>Indexing Strategies</title>
      <link>https://nolleh.github.io/mysql/indexing-strategies/</link>
      <pubDate>Mon, 24 Jul 2023 08:44:12 +0900</pubDate>
      <guid>https://nolleh.github.io/mysql/indexing-strategies/</guid>
      <description>Overview in data driven application&amp;rsquo;s poorly designed indexes and a lack of indexes are primary sources bottlenecks. As databases grow in size, finding efficient ways to retrieve and manipluate data becomes increasingly important. Basics of Indexing a database index serves a similar purporse in that of book, speeding up data retrieval without needing to scan every row in a database table
the structure of a database index includes an ordered list of values, with each value connected to pointers leading to data pages where these alues reside.</description>
    </item>
    <item>
      <title>How to Make Package</title>
      <link>https://nolleh.github.io/npm/how-to-make-package/</link>
      <pubDate>Wed, 12 Jul 2023 08:29:46 +0900</pubDate>
      <guid>https://nolleh.github.io/npm/how-to-make-package/</guid>
      <description>패키지를 만들때 기본 구성
{ &amp;#34;main&amp;#34;: &amp;#34;./dist/cjs/index.js&amp;#34;, &amp;#34;types&amp;#34;: &amp;#34;./dist/cjs/types/index.d.ts&amp;#34;, &amp;#34;files&amp;#34;: [ &amp;#34;dist/**/*&amp;#34; ], &amp;#34;scripts&amp;#34;: { &amp;#34;clean&amp;#34;: &amp;#34;rm -rf ./dist&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;pnpm run clean &amp;amp;&amp;amp; pnpm build:esm &amp;amp;&amp;amp; pnpm build:cjs&amp;#34;, &amp;#34;build:esm&amp;#34;: &amp;#34;tsc -p ./tsconfig.esm.json &amp;amp;&amp;amp; mv dist/esm/index.js dist/esm/index.mjs&amp;#34;, &amp;#34;build:cjs&amp;#34;: &amp;#34;tsc -p ./tsconfig.cjs.json&amp;#34;, &amp;#34;prepack&amp;#34;: &amp;#34;pnpm build&amp;#34; }, &amp;#34;repository&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;git&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/nolleh/serialize-interceptor&amp;#34; }, &amp;#34;keywords&amp;#34;: [ &amp;#34;nestjs&amp;#34;, &amp;#34;nest.js&amp;#34;, &amp;#34;serialize&amp;#34;, &amp;#34;deserialize&amp;#34;, &amp;#34;camel&amp;#34;, &amp;#34;snake&amp;#34;, &amp;#34;json&amp;#34;, &amp;#34;dto&amp;#34;, &amp;#34;transform&amp;#34; ], &amp;#34;exports&amp;#34;: { &amp;#34;.&amp;#34;: { &amp;#34;import&amp;#34;: { &amp;#34;types&amp;#34;: &amp;#34;.</description>
    </item>
    <item>
      <title>Writing Plugin</title>
      <link>https://nolleh.github.io/vim/writing-plugin/</link>
      <pubDate>Sat, 14 Jan 2023 14:00:53 +0900</pubDate>
      <guid>https://nolleh.github.io/vim/writing-plugin/</guid>
      <description>Writing Plugin 제목은 거창하게 썼지만, 플러그인이나 rc 파일 작성에 필요한 지식들을 메모해 둘 예정.
Preview Window :botright pedit { file } :botright pedit Preview Window 에서 라인 출력 function! showInPreview(name, fileType, lines) let l:command = &amp;#34;silent! pedit! +setlocal\\ &amp;#34; . \ &amp;#34;buftype=nofile\\ nobuflisted\\ &amp;#34; . \ &amp;#34;noswapfile\\ nonumber\\ &amp;#34; . \ &amp;#34;filetype=&amp;#34; . a:fileType . &amp;#34; &amp;#34; . a:name exe l:command if has(&amp;#39;nvim&amp;#39;) let l:bufNr = bufnr(a:name) call nvim_buf_set_lines(l:bufNr, 0, -1, 0, a:lines) else call setbufline(a:name, 1, a:lines) endif endfunction stackExchange</description>
    </item>
    <item>
      <title>4-2.graphical Desktop</title>
      <link>https://nolleh.github.io/linux/4.graphical-interface/2.graphical-desktop/</link>
      <pubDate>Sun, 08 Jan 2023 23:02:17 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/4.graphical-interface/2.graphical-desktop/</guid>
      <description>Graphical Desktop Graphical Desktop CLI or GUI.
GUI is quick and easy.
for repeated tasks, the CLI is often more efficient, while the GUI is easier to navigate if you do not remember all the details or do something only rarely.
X Window System X window system is loaded as one of the final steps in boot process. It is often just called X.
A service called the Display Manager keeps track of displays being provided and loads the X server (so-called, because it provides graphical services to applications, sometimes called X clients.</description>
    </item>
    <item>
      <title>4-1.introduction</title>
      <link>https://nolleh.github.io/linux/4.graphical-interface/1.introduction/</link>
      <pubDate>Sun, 08 Jan 2023 23:00:29 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/4.graphical-interface/1.introduction/</guid>
      <description>Graphical interface Learning Objectives By the end of this chapter, you should be able to:
Manage graphical interface sessions. Perform basic operations using the graphical interface. Change the graphical desktop to suit your needs. </description>
    </item>
    <item>
      <title>3-6.summary</title>
      <link>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/6.summary/</link>
      <pubDate>Sun, 08 Jan 2023 15:32:36 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/6.summary/</guid>
      <description>Summary Chapter Summary A partition is a logical part of the disk. A filesystem is a method of storing/finding files on a hard disk. By dividing the hard disk into partitions, data can be grouped and separated as needed. When a failure or mistake occurs, only the data in the affected partition will be damaged, while the data on the other partitions will likely survive. The boot process has multiple steps, starting with BIOS, which triggers the boot loader to start up the Linux kernel.</description>
    </item>
    <item>
      <title>3-5.linux Distribution Installation</title>
      <link>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/5.linux-distribution-installation/</link>
      <pubDate>Sun, 08 Jan 2023 14:15:48 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/5.linux-distribution-installation/</guid>
      <description>Linux Distribution Installation Choosing a Linux Distribution Questions to Ask when Choosing a Distribution What is the main function of the system (server or desktop)? What types of packages are important to the organization? For example, web server, word processing, etc. How much hard disk space is required and how much is available? For example, when installing Linux on an embedded device, space is usually constrained. How often are packages updated?</description>
    </item>
    <item>
      <title>3-4.linux Filesystem Basics</title>
      <link>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/4.linux-filesystem-basics/</link>
      <pubDate>Sun, 08 Jan 2023 13:44:22 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/4.linux-filesystem-basics/</guid>
      <description>3-4. Linux FileSystem Basics Linux FileSystem Conventional disk filesystems: ext3, ext4, XFS, Btrfs, JFS, NTFS, vfat, exfat, etc. Flash storage filesystems: ubifs, jffs2, yaffs, etc. Database filesystems Special purpose filesystems: procfs, sysfs, tmpfs, squashfs, debugfs, fuse, etc. Partitions and Filesystems A partition is physically contiguous section of disk, or what appears to be so in some advanced setups.
A filesystem is a method of storing/finding files on the hard disk (usually in a partition).</description>
    </item>
    <item>
      <title>3-3.kernel Init and Services</title>
      <link>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/3.kernel-init-and-services/</link>
      <pubDate>Sun, 08 Jan 2023 12:25:09 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/3.kernel-init-and-services/</guid>
      <description>Kernel, init and Services The Linux Kernel boot loader loads kernel and an initial RAM-based file system (initramfs) into memory, so it can be used directly by the kernel.
kernel loaded, it immediately initializes and configures the computer&amp;rsquo;s memory and also configures all the hardware attached to the system.
also load user space applications.
/sbin/init and Services Once kernel has set up all its hardware and mounted the root filesystem, the kernel runs sbin/init.</description>
    </item>
    <item>
      <title>Shell</title>
      <link>https://nolleh.github.io/cheatsheet/shell/</link>
      <pubDate>Sun, 01 Jan 2023 10:44:05 +0900</pubDate>
      <guid>https://nolleh.github.io/cheatsheet/shell/</guid>
      <description>Cheatsheet - Shell 쉘 커맨드들을 자주 까먹곤 해서 자주쓰는것 위주로 생각날때마다 하나씩 등록 예정.
Primitives if statement if [ 10 -gt 20 ]; then echo &amp;#39;gt&amp;#39;; else echo &amp;#39;lt&amp;#39;; fi; operator desc ! not true -n 문자열의 길이가 0보다 크다 -z 문자열의 길이가 0이다 = 문자열이 같다 -eq 정수가 같다 -gt 정수가 크다 -lt 정수가 작다 -d dir dir 디렉토리가 있다 -e file file 이 있다 for statement for file in *.</description>
    </item>
    <item>
      <title>3-2.the Boot Process</title>
      <link>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/2.the-boot-process/</link>
      <pubDate>Sun, 25 Dec 2022 22:21:34 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/2.the-boot-process/</guid>
      <description>The Boot Process The Linux boot process is the procedure for initializing the system.
from when the computer power is first swithced on until the user interface is fully operational.
having a good understanding of the steps in the boot process may help you with troubleshooting problems, as well as with tailoring the computer&amp;rsquo;s performance to your needs.
On the other hand, the boot process can be rather technical, and you can start using Linux without knowing all the details.</description>
    </item>
    <item>
      <title>3-1.introduction</title>
      <link>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/1.introduction/</link>
      <pubDate>Sun, 25 Dec 2022 22:19:08 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/3.linux-basics-and-system-startup/1.introduction/</guid>
      <description>Learning Objectives Identify Linux filesystems. Identify the differences between partitions and filesystems Describe the boot process. Install Linux on a computer. </description>
    </item>
    <item>
      <title>2-6.chapter summary</title>
      <link>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/6.chapter-summary/</link>
      <pubDate>Sun, 25 Dec 2022 22:02:31 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/6.chapter-summary/</guid>
      <description>Chapter Summary Linux boroows heavily from UNIX operating system, with withch its creators were well-versed. LInux accesses many features and services through files and file-like objects. Linux is a fully multi-tasking, multi-user operating system, with built-in networking and service processes known as deamons. Linux is developed by a loose confederation of developers from all over the world, collaborating over the Internet,
with Linus Torvalds at th head. Technical sill and a desire to contriubte are the only qualifications for participating.</description>
    </item>
    <item>
      <title>2-5.linux Distribution</title>
      <link>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/5.linux-distribution/</link>
      <pubDate>Sun, 25 Dec 2022 21:38:28 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/5.linux-distribution/</guid>
      <description>Linux Distribution Overview making sure that project works properly on the most widely used Linux distributions. To accomplish this, you need to learn amout the different components, services, and configurations associated with each distribution.</description>
    </item>
    <item>
      <title>2-4.linux Terminology Overview</title>
      <link>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/4.linux-terminology-overview/</link>
      <pubDate>Sun, 25 Dec 2022 21:27:09 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/4.linux-terminology-overview/</guid>
      <description>Video: Linux Terminology Kernel: Glue between hardware and applications
Ditribution: Collection of software making up a Linux-based OS
BootLoader: Program that boots the operating system
Service: Program that runs as a background process
Filesystem: Method for sotring and organizing files
X window System: toolkit and protocol to build graphical subsystem
Shell: command line interpreter</description>
    </item>
    <item>
      <title>2-3.linux Philosophy</title>
      <link>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/3.linux-philosophy/</link>
      <pubDate>Sun, 25 Dec 2022 14:37:33 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/3.linux-philosophy/</guid>
      <description>Linux Philosophy Overview Linux is constantly enhanced and maintained by a network of developers from all over the world collaborating over the internet, with Linus Torvalds at the head.
Linux Philosophy Linux borrows heavily from the well-established UNIX operating system. it was written to be a free and open source system to be used in place of UNIX,
which at the time was designed for computers much more powerful than PCs and was quite expensive.</description>
    </item>
    <item>
      <title>2-2.linux History</title>
      <link>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/2.linux-history/</link>
      <pubDate>Sun, 11 Dec 2022 23:42:16 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/2.linux-history/</guid>
      <description>Linux History Overview initially developed on and for intel x86-based personal computers.
Linux History Linus Torvalds was a student in Helsinki, Finland, in 1991, when he started a project: writing his own operating system kernal. collected together and/or developed the other essential ingredients required to construct an entire operating system with his kernel at the center.
In 1992, Linux was re-licensed using General Public License (GPL) by GNU (a project of the Free Software Foundation or FSF, which promotes freely available software),</description>
    </item>
    <item>
      <title>2-1.introduction</title>
      <link>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/1.introduction/</link>
      <pubDate>Sun, 11 Dec 2022 23:23:50 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/2.linux-philosophy-and-concepts/1.introduction/</guid>
      <description>The Power of Linux Three Important Pieces of Context Things change in Linux
Linux is contantly evolving. no matter how hard to make up-to-date as possible, Course &amp;lt;-/-&amp;gt; Linux
We have repeated some things in the class meterial
We have tried to avoid holy wars
there are many areas where there are strong preference disagreements in the Linux (and wider open source) community. examples include the best editor: emacs vs. vi; GNOME vs.</description>
    </item>
    <item>
      <title>1-3.course Linux Requirements</title>
      <link>https://nolleh.github.io/linux/1.the-linux-foundation/3.course-linux-requirements/</link>
      <pubDate>Sun, 11 Dec 2022 22:23:30 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/1.the-linux-foundation/3.course-linux-requirements/</guid>
      <description>Course Software Requirements to fully benefit from this course, at least one linux distribution installed.
you will learn some more details about many available Linux distributions and the failies thy can be considered to belong to.
focus on 3 major distribution families.
Focus on Three Major Linux Distribution Families The Red Hat Family Red Hat Enterprise Linux (RHEL) heads the family that includes CentOS, CentOS Stream, Fedora and Oracle Linux.</description>
    </item>
    <item>
      <title>1-2.the Linux Foundation</title>
      <link>https://nolleh.github.io/linux/1.the-linux-foundation/2.the-linux-foundation/</link>
      <pubDate>Sun, 11 Dec 2022 21:55:34 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/1.the-linux-foundation/2.the-linux-foundation/</guid>
      <description>founded in 2000, supported by more than 1,000 members and is the world&amp;rsquo;s leading home for collaboration on open source software.
the foundation hosts hundreds of world&amp;rsquo;s most important open source projects including linux, kubernetes, Node.js, Hyperledger, ONAP&amp;hellip; and many more.</description>
    </item>
    <item>
      <title>1-1.Introduction</title>
      <link>https://nolleh.github.io/linux/1.the-linux-foundation/1.introduction/</link>
      <pubDate>Sun, 11 Dec 2022 21:55:20 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/1.the-linux-foundation/1.introduction/</guid>
      <description>we will learn&amp;hellip;
linux foundation logistics of this online course choosing a linux distribution that&amp;rsquo;s right for you </description>
    </item>
    <item>
      <title>Welcome</title>
      <link>https://nolleh.github.io/linux/welcome/</link>
      <pubDate>Sun, 11 Dec 2022 21:50:09 +0900</pubDate>
      <guid>https://nolleh.github.io/linux/welcome/</guid>
      <description></description>
    </item>
    <item>
      <title>Overview</title>
      <link>https://nolleh.github.io/svelte/overview/</link>
      <pubDate>Tue, 11 Oct 2022 23:34:14 +0900</pubDate>
      <guid>https://nolleh.github.io/svelte/overview/</guid>
      <description>서론 react, vue, angluar 가 장악하던 FE 진영에서 떠오르고 있는 프레임워크. 주요 철학은 svelte 의 메인 화면에서 보여주고 있는것처럼 &amp;lsquo;보다 짧은 코드&amp;rsquo;, &amp;lsquo;No Virtual DOM&amp;rsquo;, &amp;lsquo;Truely reactive&amp;rsquo; 인 듯하다. 지만 나는 어디까지나 BE 개발자이기 때문에 아직 어떤 의미인지 자세하게는 모르겠고(&amp;hellip;)
스벨트 컬럼을 새로 생성하며 블로그에 정리를 결심한 것은 어디까지나 호기심이 충만한 나의 심심풀이 변덕이다. (더 정확히는, 팀 내 주니어 개발자와의 원활한 의사 소통을 위해..) 심심할 때 더 자세히 살펴보고 정리할 것.</description>
    </item>
    <item>
      <title>Dont Lock on Async Tasks</title>
      <link>https://nolleh.github.io/csharp/dont-lock-on-async-tasks/</link>
      <pubDate>Tue, 06 Sep 2022 00:20:16 +0900</pubDate>
      <guid>https://nolleh.github.io/csharp/dont-lock-on-async-tasks/</guid>
      <description>서론 예전 회사에서나 현 직장에서나, 면접관으로 들어가다가 C# 이 이력서에 적혀있는 경우 Task 와 async/await 관련하여 동기화 관련한 내용에 대해 물어보곤한다. 그리고 이 질문에서 대부분 깊이가 드러나게 된다. (여담이지만, 대부분의 지원자가 자바스택이라, 이런 재미진? 것들을 물어보기가 어렵다. C# 이랑 C++, 실시간 게임서버는 재미진 질문? 들이 많은데.. ㅎㅎㅎㅎ 면접관으로 들어가기위해서 자바스택의 재미진 토픽들도 좀 찾아봐야겠다&amp;hellip;.
내 경험에서 질문을 도출하려고 스프링의 라이브러리들을 어떻게 구현할 수 있을지 물어볼수는 없으니&amp;hellip;) 물어보다가 나도 생각도 정리하고, 내가 알고 있는 틀린 부분이 없는지 정리하는겸해서 블로그에 기록해 놓는다.</description>
    </item>
    <item>
      <title>Note</title>
      <link>https://nolleh.github.io/coursera/data-analyst-ibm/week1/note/</link>
      <pubDate>Sun, 04 Sep 2022 13:55:28 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/data-analyst-ibm/week1/note/</guid>
      <description>role of data analyst sicentist: modeling. analyze data for actionable insight and build ML or DLM anaylsts : data to find trends and patterns, for buisiness decisions. engineer : extract and organie data from different sources, store and manage data repositorioes, so that other data professionals can access it. build your skills as a data analyst Data Analyst Expert view point </description>
    </item>
    <item>
      <title>Mac 터미널에서 복수의 유저 사용하기</title>
      <link>https://nolleh.github.io/env/mac-terminal-multiple-user/</link>
      <pubDate>Wed, 24 Aug 2022 00:49:49 +0900</pubDate>
      <guid>https://nolleh.github.io/env/mac-terminal-multiple-user/</guid>
      <description>복수의 유저 사용하기 맥터미널에서 복수의 유저를 사용하려면 몇가지 신경써야할 부분들이 생긴다.
home directory 가 분리 되어 있기 때문에 어떤 유저를 위해 설치한 데이터들은
다른 유저에서는 사용못할수도 있고 (그러는게 맞고, 그럴려고 격리한거니)
그러다보니 양쪽에서 같은 데이터를 설치해야하나 ?
혹은 서로 충돌이 난다거나 하는 불편함들이 생긴다.
대표적인 예로 brew 에서 이런 문제가 발생하는데,,
어떤 계정으로 설치한 패키지가 다른 계정에서 권한문제로 접근이 안되게 되면서 엉망이 된다.. (-_&amp;ndash;) dependency 가 있는 다른 패키지 들과도 맞물리게 되면서 내가 설치한 패키지가 아닌 패키지에 대해 데이터를 바꾸려고 하면서 권한 이슈로 연결 되는식.</description>
    </item>
    <item>
      <title>Functions</title>
      <link>https://nolleh.github.io/mysql/functions/</link>
      <pubDate>Sat, 06 Aug 2022 12:06:41 +0900</pubDate>
      <guid>https://nolleh.github.io/mysql/functions/</guid>
      <description>Overview 개인적으로 업무 진행중 빠르게 DB 데이터를 bulk 로 넣어야할 때에는 function 생성을 선호하는 편이다.
ORM 을 통해 코드로 넣는 방법도 있지만, 코드 수정하고 코드를 다시 실행해서 테스트 코드를 돌리고 데이터 결과를 쿼리로 다시 확인하는것보다. 쿼리를 바로 바로 작성해서 바로 수정하는게 더 생산성이 좋기 때문.
코드 작성 (IDE) 프로그램 실행 (SVR APP) 테스트 코드 실행 (SWAGGER BROWSER) 데이터 삽입 결과 확인 (DB CLIENT) VS
function 작성 (DB CLIENT) function 실행 (DB CLIENT) 데이터 삽입 결과 확인 (DB CLIENT) 절차는 크게 차이나지 않아보이지만, 화면 이동, 적합한 프로그램 실행등의 과정에서 누적되면 생산성의 차이가 발생한다.</description>
    </item>
    <item>
      <title>Cheatsheet</title>
      <link>https://nolleh.github.io/mysql/cheatsheet/</link>
      <pubDate>Sat, 06 Aug 2022 12:05:08 +0900</pubDate>
      <guid>https://nolleh.github.io/mysql/cheatsheet/</guid>
      <description></description>
    </item>
    <item>
      <title>Cheatsheet</title>
      <link>https://nolleh.github.io/kubernetes/cheatsheet/</link>
      <pubDate>Fri, 05 Aug 2022 16:22:31 +0900</pubDate>
      <guid>https://nolleh.github.io/kubernetes/cheatsheet/</guid>
      <description>CronJobs 수동 실행
kubectl create job -n {namespace} --from=cronjob/{name} {job-name} </description>
    </item>
    <item>
      <title>3.time and Order</title>
      <link>https://nolleh.github.io/distributed-systems/3.time-and-order/</link>
      <pubDate>Sat, 23 Jul 2022 14:33:45 +0900</pubDate>
      <guid>https://nolleh.github.io/distributed-systems/3.time-and-order/</guid>
      <description>다음에서 발췌 3. Time and Order 순서란 무엇이고, 왜 중요할까요?
&amp;ldquo;순서란 무엇인가&amp;rdquo; 라는 질문은 무슨 의미 일까요 ?
애초에 왜 여기에 왜 빠져있는 걸까요? 왜 우리는 A 가 B 이전에 실행되었다는걸 신경 써야할까요? 왜 우리는 다른 주제에는 신경을 안쓸까요 ? 색깔 같은거?
글쎄, 친구, 일단 이에 답변하기 위해 분산 시스템을 다시 살펴보도록 합시다.
기억하고 있을지 모르겠는데, 분산프로그래밍을 복수의 컴퓨터를 활용해서 같은 문제를 해결하는 예술이라고 묘사했었습니다.
이것은, 사실, 순서에 대한 강박(obsession)의 가장주요한 내용입니다.</description>
    </item>
    <item>
      <title>2.level of Abstraction</title>
      <link>https://nolleh.github.io/distributed-systems/2.level-of-abstraction/</link>
      <pubDate>Wed, 29 Jun 2022 22:15:08 +0900</pubDate>
      <guid>https://nolleh.github.io/distributed-systems/2.level-of-abstraction/</guid>
      <description>다음에서 발췌 http://book.mixu.net/distsys/abstractions.html
2. Up and down the level of abstraction 이 챕터에서는, 추상화의 레벨을 여행할 것이며, 몇가지 불가능한 결과를 보고, (CAP 와 FLP), 그리고 나서 성능에 대한 항해를 할 것 입니다.
만약 어떤 프로그래밍을 완료했다면, 추상화. 수준에 대한 개념은 당신에게 익숙할 겁니다. 당신은 이미 추상화와 함께 했고, 어떤 API 를 통해 더 낮은 레이어와 인터페이싱하고 있을 것이며, 더 높은 레이어에 API 나 인터페이스를 제공하고있을 겁니다. OSI 네트워크 7 계층이 좋은 예죠.</description>
    </item>
    <item>
      <title>서브 모듈 추가하기</title>
      <link>https://nolleh.github.io/git/sub-module/</link>
      <pubDate>Sun, 29 May 2022 16:37:55 +0900</pubDate>
      <guid>https://nolleh.github.io/git/sub-module/</guid>
      <description>자주 사용하는 서브 모듈 명령어.
add submodule git submodule add {remote-repo} update git submodule init
git 에서 서브모듈을 관리하기위한 설정파일, gitmodules 를 설정한다. git submodule update remote 저장소로부터 업데이트 내용을 가져와서 적용한다. git submodule update --init remove submodule git submodule deinit -f {path} rm -rf .git/modules/{path} git rm -f {path} </description>
    </item>
    <item>
      <title>Active Passive Messaging Clusters</title>
      <link>https://nolleh.github.io/qpid/1.12.active-passive-messaging-clusters/</link>
      <pubDate>Thu, 06 Feb 2020 14:47:47 +0900</pubDate>
      <guid>https://nolleh.github.io/qpid/1.12.active-passive-messaging-clusters/</guid>
      <description>1.12. Active-Passive Messaging Clusters 1.12.1 Overview HA 모듈은 active-passive, hot-standby 메시징 클러스터들을 장애에 tolerent 하도록 제공한다.
active-passive 클러스터는 하나의 브로커만 존재하며, 이를 프라이머리라고 부르며, 액티브 하고 클라이언트를 serving 한다. 다른 브로커들은 백업을 위해 존재한다. 프라이머리의 변경은 모든 백업들에 반영되므로, 백업들은 최신상태이거나 &amp;lsquo;hot&amp;rsquo; 상태이다. 백업 브로커들은 클라이언트의 연결을 거부하며, 클라이언트들은 프라이머리에 연결해야한다.
만약 프라이머리가 실패하는 경우, 백업중의 하나가 새로운 프라이머리가 되기위해 자리를 차지한다. 클라이언트는 새로운 프라이머리에 자동으로 연결한다.
만약 복수개의 백업이 있다면, 다른 백업들은 새로운 프라이머리의 백업이 되도록 장애처리를 진행한다.</description>
    </item>
    <item>
      <title>Broker Federation</title>
      <link>https://nolleh.github.io/qpid/1.4.broker-federation/</link>
      <pubDate>Thu, 06 Feb 2020 13:23:27 +0900</pubDate>
      <guid>https://nolleh.github.io/qpid/1.4.broker-federation/</guid>
      <description>1.4 Broker Federation 메시지 라우트를 정의하여 하나의 브로커에서 다른 브로커로 자동으로 전달하게 한다.
일반적으로 일방향이며, 라우트는 durable 하고 tansient 한다.
연결이 소실되면 메시지는 누적되다가 재연결이 되면 다시 전송한다.
라우팅에 사용되는 룰은 서버가 변경됨에 따라 동적으로 변경할 수 있으며, 변경의 책임은 다른 변경조건에 맞게 반영된다,.
1.4.1 Message Routes pull / push 방식이 있음.
pull 은 dest 에서.
push 는 src 에서 설정함
queue &amp;lt;-&amp;gt; exchage exchange &amp;lt;-&amp;gt; exchange excg &amp;lt;-&amp;gt; excg 는 다음과 같은 라우트를 가질 수 있다.</description>
    </item>
    <item>
      <title>Network</title>
      <link>https://nolleh.github.io/cheatsheet/network/</link>
      <pubDate>Thu, 06 Feb 2020 11:56:11 +0900</pubDate>
      <guid>https://nolleh.github.io/cheatsheet/network/</guid>
      <description>time_wait 종료 시간 확인 : ndd -get /dev/tcp tcp_time_wait_interval time_wait 종료 시간 30초로 설정 : ndd -set /dev/tcp tcp_time_wait_interval 30000 fin_wait_2 타임 아웃 시간 확인 : ndd -get /dev/tcp tcp_fin_wait_2_timeout fin_wait_2 타임 아웃 시간 5분으로 설정 : ndd -set /dev/tcp tcp_fin_wait_2_timeout 300000 출처: https://hyeonstorage.tistory.com/287 [개발이 하고 싶어요]</description>
    </item>
    <item>
      <title>Docker</title>
      <link>https://nolleh.github.io/cheatsheet/docker/</link>
      <pubDate>Thu, 06 Feb 2020 10:53:37 +0900</pubDate>
      <guid>https://nolleh.github.io/cheatsheet/docker/</guid>
      <description>Docker Cheat Sheet 1. docker conntainer 내부 소켓 상태 확인 $ docker inspect -f &amp;#39;{{.State.Pid}}&amp;#39; cb2939r52s22 5645 [ec2-user@ip-10-100-77-76 ~]$ sudo nsenter -t 5645 -n netstat Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 ip-172-17-0-2.ec2.:webcache ip-10-100-77-225.ec2.:45104 ESTABLISHED tcp 0 0 ip-172-17-0-2.ec2.:webcache ip-10-100-77-225.ec2.:14804 TIME_WAIT tcp 0 0 ip-172-17-0-2.ec2.:webcache ip-10-100-76-6:seclayer-tls TIME_WAIT tcp 0 0 ip-172-17-0-2.ec2.:webcache ip-10-100-76-65.ec:plethora TIME_WAIT tcp 0 0 ip-172-17-0-2.ec2.:webcache ip-10-100-77-225.ec2.:14830 TIME_WAIT tcp 0 0 ip-172-17-0-2.</description>
    </item>
    <item>
      <title>Clustering Guide</title>
      <link>https://nolleh.github.io/rabbitmq/clustering-guide/</link>
      <pubDate>Wed, 05 Feb 2020 18:44:37 +0900</pubDate>
      <guid>https://nolleh.github.io/rabbitmq/clustering-guide/</guid>
      <description>한개 이상의 노드들의 논리적인 그룹을 의미하며, 각각은 유저와, 가상 호스트, 큐, exchanges, bindings 을 공유한다.
Cluster Formation 다음 방법들로 구성 가능
Declaratively by listing cluster nodes in config file Declaratively using DNS-based discovery Declaratively using AWS (EC2) instance discovery (via a plugin) Declaratively using Kubernetes discovery (via a plugin) Declaratively using Consul-based discovery (via a plugin) Declaratively using etcd-based discovery (via a plugin) Manually with rabbitmqctl 구성은 동적으로 변경 될수 있고, 모든 RabbitMQ 브로커는 하나의 노드로부터 시작해서 클러스터에 참여시키거나, 다시 개별의 브로커로 돌아갈 수 있다.</description>
    </item>
    <item>
      <title>SSL</title>
      <link>https://nolleh.github.io/crypto/ssl/</link>
      <pubDate>Thu, 30 Jan 2020 18:29:58 +0900</pubDate>
      <guid>https://nolleh.github.io/crypto/ssl/</guid>
      <description></description>
    </item>
    <item>
      <title>ECDSA</title>
      <link>https://nolleh.github.io/crypto/ecdsa/</link>
      <pubDate>Thu, 30 Jan 2020 18:28:50 +0900</pubDate>
      <guid>https://nolleh.github.io/crypto/ecdsa/</guid>
      <description>ECDSA ref. https://m.blog.naver.com/aepkoreanet/221178375642
ec (타원곡선) 을 이용한 기술들의 집합 - ECC,
이중에 디지털서명 관련 기술이 ECDSA
Terms 유한체
집합에 속해있는 원소의 수가 한정되어 있고 덧셈, 곱셈에 대해 닫혀있는 집합 유한체 F 표기법
원소의 개수가 p 인 유한체 F 는 Fp 혹은 GF(p) 로 표기 유한체 상에 정의된 타원 곡선
E(Fp) 암호학에서 사용되는 유한체 - Prime Field 원소의 개수가 소수 ECC 사용시 타원 곡선을 정의하는 domain parameter 를 정의해야함. (p, a, b, G, n, h) 를 정의해야하는건데, 여러 표준단체에서 Field Size 에 맞는 타원곡선에 대한 파라미터 발표.</description>
    </item>
    <item>
      <title>6. DataStorage</title>
      <link>https://nolleh.github.io/coursera/gcp/6.datastorage/</link>
      <pubDate>Sat, 16 Mar 2019 23:02:25 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/6.datastorage/</guid>
      <description>Best Practices for Using Cloud Storage 버킷에 변화가 있을때 반응하게 할 수 있다. https://cloud.google.com/storage/docs/pubsub-notifications
Demo coldline 은 일년에 한번 접근하는것과 같은 문제발생시 복구하는 용도로 사용하면 좋다..
https://cloud.google.com/storage/docs/managing-lifecycles
Demo2 - Cors cors - https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS cross-origin-resource sharing
instance 만들고 / apache 깔고 / cors 설정 여는 데모..
Best Practices for cloud Storage request rate 가 초당 1000 쓰기 요청 이나 5000 읽기 요청을 넘어가면 ..
이 기준 요청량내에서 요청을 시작해서 20 분마다 요청을 두배로 해라.</description>
    </item>
    <item>
      <title>5. Cloud DataStore Concepts and Indexes</title>
      <link>https://nolleh.github.io/coursera/gcp/5.datastore/</link>
      <pubDate>Sat, 16 Mar 2019 11:34:29 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/5.datastore/</guid>
      <description>Cloud Datastore Concepts and Indexes Cloud Data Store concepts 데이터 오브젝트는 엔터티라고 불림 엔터티들은 하나이상의 프로퍼티로 구성됨 프로퍼티들은 하나이상의 값(values) 를 가질수 있음 각각의 엔터티는 구분되는 하나의 키를 가지고 있는데, 다음으로 구성 된다. 네임스페이스 엔터티 Kind 식별자 (스트링 or 숫자) 부모 ID 하나 이상의 엔터티에 대한 동작은 트랜잭션으로 불린다. Datastore has two types of indexes Built-in indexes Composite indexes 각각의 엔터티 Kind의 각각의 프로퍼티에 대해 자동으로 정의 인덱싱된 엔터티에 대해 다중의 프로퍼티 값을 인덱스함 간단한 쿼리에 적합 컴플렉스 쿼리에 적합 인덱스 설정파일에 정의 concept cloud datastore relational database 오브젝트 카테고리 Kind Table 한개 오브젝트 entity row 하나의 오브젝트를 위한 개별 데이터 프로퍼티 field 유니크 ID Key PrimaryKey Design Considerations &amp;amp; Sharding Design Your application for scale 엔터티 그룹에 대한 최대 쓰기율은 1/초 사전적으로 가까운 키에 대한 읽기와 쓰기를 너무 자주하지 말것.</description>
    </item>
    <item>
      <title>4.Cloud Storage, Cloud Datastore, Cloud Bigtable, Cloud SQL, and Cloud Spanner</title>
      <link>https://nolleh.github.io/coursera/gcp/4.db-overview/</link>
      <pubDate>Sat, 16 Mar 2019 11:33:59 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/4.db-overview/</guid>
      <description>Cloud Storage 크고 자주 사용되지 않은 비구조화된 데이터
Overview ideal for 완전히 관리되고 고 신뢰가능 이미지와 비디오 비용절감. 확장가능한 오브젝트/블롭 저장 오브젝트와 블롭 http 로 접근 구조화되어있지 않은 데이터 오브젝트 이름이 키 정적 웹사이트 호스팅 Ideal for Cloud Datastore 관계형이나 데이터 분석에는 적합하지 않고 GAE 앱이나 구조화된 순수 제공 사용례에 적합한 구조화된 제공을 위한 스케일러블 저장소.
OverView ideal for NoSQL 도큐먼트 데이터베이스 세미구조의 어플리케이션 데이터 확장가능 내구성이 필요한 키 밸류 데이터 계층구조 데이터 복수 인덱스 매니징 트랜잭션 Cloud Bigtable 고구조화 / 트랜잭셔널 데이터에는 적합하지 않고, flat 하고 많은 read/write 연산이나 분석을 위한 데이터에 적합한 큰 용량의 저지연 데이터베이스.</description>
    </item>
    <item>
      <title>3.SDK</title>
      <link>https://nolleh.github.io/coursera/gcp/3.sdk/</link>
      <pubDate>Tue, 12 Mar 2019 23:37:51 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/3.sdk/</guid>
      <description>What are the Google Cloud Client Libraries? 관용적인 코드를 각각의 랭귀지에 대해 제공 gRPC 에서 성능 효과를 보는 라이브러리도 있다.
github repo
gcloud - 커맨드 라인툴, gcp를 위한.
GC cloud 빅쿼리를 위한 커맨드라인 툴
gsuitl 버킷이랑 통신하기 위한 커맨드라인 툴
gcloud init (initialize )
Cloud Shell 브라우저 베이스 커맨드라인툴. 일시적인 vm에 대한 접근을 제공. 5GB 디스크 SDK 에 이미 설치되어있음
구글클라우드 콘솔프로젝트에대한 authorization /리소스 제공
코드 에디터가 포함 (beta)
Module Review Api Explore: google cloud api 를 테스트하기위한 샌드박스로 사용 Google Cloud Client Library : GCP 서비스와 커뮤니케이션 GCP Service 의 스크립트 작성 : Google Cloud SDK</description>
    </item>
    <item>
      <title>1-1. 계정관리를 위한 12 tips</title>
      <link>https://nolleh.github.io/coursera/gcp/1-1.12-tips/</link>
      <pubDate>Tue, 12 Mar 2019 21:52:58 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/1-1.12-tips/</guid>
      <description>12 Best Practices for user saccount https://cloud.google.com/blog/products/gcp/12-best-practices-for-user-account GCP 에서는 유저 계정에 대한 안전한 핸들링과 인증을 위한 툴을 게공한다. 웹사이트가 구글 쿠버네티스엔진에 호스트 되는 웹사이트를 담당하든, apigee 의 api 를 담당하든, firebase 를 사용하든, 어떤 다른 서비스를 통해 유저를 인증하든, 이 포스트는 좋은 연습을 제공해서, 안전하고 확장가능하고 쓸만한 계정 인증 시스템을 사용할 수 있게 도와줄 것이다.
1. 패스워드를 해시하라. 패스워드를 포함해서, 예민한 개인정보를 어떻게 저장할 것인가가 계정관리의 가장 중요한 규칙이다. 이 데이터를 신성하게 다뤄야한다.</description>
    </item>
    <item>
      <title>2.Security-Reliability-Migration</title>
      <link>https://nolleh.github.io/coursera/gcp/2.security-reliability-migration/</link>
      <pubDate>Tue, 12 Mar 2019 21:52:02 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/2.security-reliability-migration/</guid>
      <description>3. Security, Reliablitiy, and Migration Use federated identity management firebase authentication~ 외부의 identity provider 를 통해 ..
Implement health-check endpoint Stackdriver monitoring (helth monitoring agent) -&amp;gt; /health upcheck. 어디에 ? storage / database, network connection, 다른 의존들 .. 실패하면 자동으로 알림을 준다.
로깅과 모니터를 어플리케이션의 성능에 대해 두라. 로그를 이벤트 스트림으로 취급하라. 어플리케이션에서는 건들지 말고 stdout 등으로 노출되는 데이터를 다른애가 후처리 해라 . 구글의 스택드라이버를 통해 어플리케이션을 디버그할 수 있고, 에러 모니터링을 설정할 수 있다.</description>
    </item>
    <item>
      <title>1.MSA and ApiGateway</title>
      <link>https://nolleh.github.io/coursera/gcp/1.msaandapigateway/</link>
      <pubDate>Tue, 12 Mar 2019 21:51:32 +0900</pubDate>
      <guid>https://nolleh.github.io/coursera/gcp/1.msaandapigateway/</guid>
      <description>Loosely Coupled Microservices and API gateway 모놀리틱에서는 기본 코드가 부풀게 되서, 어디를 고쳐야하는지 알기가 어렵다. 패키지들의 의존성들이 얼키고 설킨다.
작은 기본 코드를 고쳐도 전체 프로그램이 배포되어 테스트될 필요가 있다.
원격지에 의한 제어는 비동기 처리를 하자.
가능한한 이벤트 드리븐 처리를 하자. -&amp;gt; 예를들어 구글 클라우드서비스에 이미지를 업데이트하고~ 이 이벤트에 반응하여 동작하는 어플리케이션을 만들 수 있다.
커플링을 줄이기 위해 메시지 큐 등을 사용할 수 있다. 토픽에 대해 발송, 받아 처리.
Cache content 반응성을 위해 컨텐츠를 캐싱해서, TTL 이 지나기전의 캐쉬 데이터를 준다.</description>
    </item>
    <item>
      <title>Building Distributed App</title>
      <link>https://nolleh.github.io/block-chain-youtube/building-distributed-app/</link>
      <pubDate>Wed, 23 Jan 2019 20:32:59 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain-youtube/building-distributed-app/</guid>
      <description>다음에서 발췌 ()[]
Smart Contract 블록은 트랜잭션을 포함한다. 트랜잭션은 액션의 기록이다. 액션은 컨트랙트의 동작이다. 스마트컨트랙트의 사용
eos.io 의 컨트랙트는 abi 로 표현된다. 어플리케이션 코드는 json data 를 이용한 http 를 통해 contract 를 트리거 한다. EOS.IO 는 컨트랙트를 간단히 스크립팅하거나 테스팅하기위한 커맨드라인 인터페이스를 제공한다. Intro Smart Contracts EOS.IO 스마트 컨트랙트는 WebAssembly 로 구동된다. (WASM)
web 표준으로 떠오르는중 c/c++ 로부터 clang/llvm 을 통해 생성된다. 다른 언어들도 언젠가 지원될 것 Transaction - 실행되는 하나이상의 액션의 집합.</description>
    </item>
    <item>
      <title>1. Distributed systems at a highlevel</title>
      <link>https://nolleh.github.io/distributed-systems/1.highlevel/</link>
      <pubDate>Mon, 21 Jan 2019 22:58:23 +0900</pubDate>
      <guid>https://nolleh.github.io/distributed-systems/1.highlevel/</guid>
      <description>다음에서 발췌 http://book.mixu.net/distsys/intro.html
1. Distributed systems at a highlevel 분산 프로그래밍은 같은 문제를 하나의 컴퓨터에서 해결할 수 있는 문제를 여러 컴퓨터에서 해결하는 예술이다. 컴퓨터 시스템이라면 해결해야 하는 두개의 문제가 있습니다.
저장소 연산 분산 프로그래밍은 하나의 컴퓨터에서 해결할 수 있는 문제를 여러 컴퓨터를 통해 해결하는 예술입니다. 보통 하나의 컴퓨터에서 해결하기에는 적합하지 않은 문제를 위해서입니다.
실세계에서의 어떤것도 분산시스템을 요구하지는 않습니다. 무한한 돈과 무한한 실시간 연구 시간이 있다면, 분산시스템은 필요없습니다. 모든 연산과 모든 저장소는 매직박스 안에서 실행 될 수 있습니다 - 하나의, 믿을 수 없을정도로 빠르고, 믿을 수 없을정도로 신뢰할 수 있는 시스템은 누군가에게 돈을 지불하거나 당신이 직접 디자인할 필요가 있겟죠.</description>
    </item>
    <item>
      <title>EOSIO - 2.1/Hello World!</title>
      <link>https://nolleh.github.io/block-chain/2.1-helloworld/</link>
      <pubDate>Tue, 01 Jan 2019 20:17:59 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/2.1-helloworld/</guid>
      <description>hello 라는 이름의 디렉토리를 contracts directory 에 생성하자.
cd CONTRACTS_DIR mkdir hello cd hello hello.cpp 를 생성하고 에디터로 열자.
touch hello.cpp 필요한 라이브러리를 이 파일에 include 한다.
#include &amp;lt;eosiolib/eosio.hpp&amp;gt; #include &amp;lt;eosiolib/print.hpp&amp;gt; 코드를 간결하게 해줄 eosio 네임스페이스를 contract 에 추가한다.
using namespace eosio; eosiolib/eosio.hpp 가 EOSIO C 와 C++ API 를 당신의 contract 스코프에 로드한다. 표준 C++11 클래스를 생성한다. 이 contract class 는 eosio::contract 를 확장해야한다.
#include &amp;lt;eosiolib/eosio.hpp&amp;gt; #include &amp;lt;eosiolib/print.hpp&amp;gt; using namespace eosio; class hello : public contract {}; 비어있는 contract 는 좋지 않으니, public 접근 지정자와 using 선언을 추가하자.</description>
    </item>
    <item>
      <title>EOSIO - 1.7/Test 계정 생성하기</title>
      <link>https://nolleh.github.io/block-chain/1.7-createtestaccount/</link>
      <pubDate>Tue, 01 Jan 2019 20:02:35 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.7-createtestaccount/</guid>
      <description>다음에서 발췌 EOSIO - 1.7 Create Test Accounts
What is an account? 블록체인에 저장되어 송신자와 수신자를 구분하는데 사용되는 승인의 집합체라 할 수 있다. 유연한 권한 승인 구조를 가질 수 있는데, 권한이 어떻게 설정되느냐에 따른 개인이나 그룹에 의해 소유될 수 있다.
하나의 계정은 블록체인의 트랜잭션을 보내거나 받기 위해 요구된다.
이 튜토리얼에서는 두개의 user 계정, bob 과 alice, 그리고 설정을 위한 기본 eosio 계정을 사용한다. 추가로 계정들은 다양한 contracts 를 위해 이 튜토리얼 시리즈에서 만들어 질 수 있다.</description>
    </item>
    <item>
      <title>EOSIO - 1.6/개발 Wallet 생성하기</title>
      <link>https://nolleh.github.io/block-chain/1.6-createdevelopmentwallet/</link>
      <pubDate>Tue, 01 Jan 2019 17:10:57 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.6-createdevelopmentwallet/</guid>
      <description>Step 1: Wallet 생성하기 먼저 wallet 을 생성한다. cleos wallet create 를 통해 기본 wallet 을 --to-console 옵션을 사용하여 간단하게 생성한다.
cleos 를 production 환경에서 사용한다면, 대신 --to-file 옵션을 사용하여 wallet 의 패스워드를 배쉬 기록에 남지않도록 한다.
개발 목적으로 사용하는 production 환경의 키가 아니기때문에 &amp;ndash;to-console 으로 보안 위협없이 사용할 수 있다.
cleos wallet create --to-console cleos 는 패스워드를 반환하며, 이 패스워드를 다음 튜토리얼에서 이용할 수 있도록 저장하자.
Creating wallet: default Save password to use in the future to unlock this wallet.</description>
    </item>
    <item>
      <title>EOSIO - 1.5/CDT 설치하기</title>
      <link>https://nolleh.github.io/block-chain/1.5-installthecdt/</link>
      <pubDate>Tue, 01 Jan 2019 16:57:50 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.5-installthecdt/</guid>
      <description>다음에서 발췌 - EOSIO - 1.5 Install The CDT
EOSIO Contract Development Toolkit, CDT 는 contract 컴파일을 위한 툴의 집합이다. 뒤따를 튜토리얼들은 contract 들을 컴파일하고 ABI 를 생성하는 주요 CDT 를 사용한다.
1.3.x 버전부터, CDT 는 Mac OS X brew, linux debian 과 RPM 패키지들을 지원한다. 설치하기 위한 가장쉬운 선택지는 이 패키지 시스템들을 이용하는 것이다. 하나의 방법을 선택하자.
HomeBrew (Mac OS X) Install brew tap eosio/eosio.cdt brew install eosio.cdt Uninstall brew remove eosio.</description>
    </item>
    <item>
      <title>EOSIO - 1.4/노드 시작하고 설정하기</title>
      <link>https://nolleh.github.io/block-chain/1.4-startyournodeandsetup/</link>
      <pubDate>Tue, 01 Jan 2019 16:36:28 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.4-startyournodeandsetup/</guid>
      <description>다음에서 발췌 - Step 1: Boot Node And Wallet Step 1.1: Start keosd 먼저 keosd 를 시작한다.
keosd &amp;amp; 다음과 유사한 결과를 얻게 된다.
info 2018-11-26T06:54:24.789 thread-0 wallet_plugin.cpp:42 plugin_initialize ] initializing wallet plugin info 2018-11-26T06:54:24.795 thread-0 http_plugin.cpp:554 add_handler ] add api url: /v1/keosd/stop info 2018-11-26T06:54:24.796 thread-0 wallet_api_plugin.cpp:73 plugin_startup ] starting wallet_api_plugin info 2018-11-26T06:54:24.796 thread-0 http_plugin.cpp:554 add_handler ] add api url: /v1/wallet/create info 2018-11-26T06:54:24.796 thread-0 http_plugin.cpp:554 add_handler ] add api url: /v1/wallet/create_key info 2018-11-26T06:54:24.</description>
    </item>
    <item>
      <title>EOSIO - 1.3/스택에 대해</title>
      <link>https://nolleh.github.io/block-chain/1.3-aboutthestack/</link>
      <pubDate>Tue, 01 Jan 2019 15:56:51 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.3-aboutthestack/</guid>
      <description>발췌 - EOSIO - 1.3 About The Stack
방금 설치한 툴들을 시작하기 전에, 각각의 컴포넌트들이 어떻게 상호작용하는지 이해하는게 좋다.
nodeos (node + eos = nodeos) - 노드를 실행하기 위한 플러그인들로 설정될 수 있는 Core EOSIO 데몬. 예제는 로컬개발과 API 종단점을 위해 블록제품을 사용한다.
cleos (cli + eos = cleos) - 블록 체인과 상호작용하고 wallet 을 관리하기위한 커맨드 라인 인터페이스.
keosd (key + eos = keosd) - wallet 안의 EOSIO key 를 안전하게 저장 하기 위한 컴포넌트</description>
    </item>
    <item>
      <title>EOSIO - 1.2/시작하기 전에</title>
      <link>https://nolleh.github.io/block-chain/1.2-beforeyoubegin/</link>
      <pubDate>Tue, 01 Jan 2019 15:27:37 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.2-beforeyoubegin/</guid>
      <description>발췌 - (EOSIO - 1.2 Before You Begin)[https://developers.eos.io/eosio-home/docs/setting-up-your-environment]
Step 1: Install Binaries 이 튜토리얼은 선빌드된 바이너리를 사용한다.
가장 빨리 시작하는 방법은 이게 가장 좋은 선택지 일것이다. 소스로부터 빌드하는 것도 하나의 선택지이지만, 한시간 이상 걸릴 수 도 있으며 빌드 에러가 발생 할 수도 있다.
아래의 명령어들이 각각의 OS 에서 바이너리를 다운로드 할 것이다.
brew tap eosio/eosio brew install eosio Step 2: Setup a development directory, stick to it 작업을 진행할 디렉토리를 선택할 필요가 있다.</description>
    </item>
    <item>
      <title>EOSIO - 1.1/소개</title>
      <link>https://nolleh.github.io/block-chain/1.1-introduction/</link>
      <pubDate>Tue, 01 Jan 2019 14:41:42 +0900</pubDate>
      <guid>https://nolleh.github.io/block-chain/1.1-introduction/</guid>
      <description>발췌 EOSIO - 1.1 Introduction
배울 수 있는 것 노드로 얼마나 빨리 갖고 놀 수 있는가 Wallet 과 Key 를 어떻게 관리할 수 있는가 계정을 만드는 법 contract 작성법 컴파일과 ABI contract 배포 C / C++ 경험 EOSIO 기반 블록체인은 WebAssembly 를 이용하여 유저가 생성한 어플리케이션과 코드를 실행한다.
WASM 은 구글, 마이크로소프트, 애플, 그리고 다른 주요 업체의 지원을 받는 떠오르는 웹 표준이다.
오늘날 WASM 을 빌드하기위해 사용되는 성숙된 도구는 C/C++ 컴파일러를 통한 clang/llvm 이다.</description>
    </item>
    <item>
      <title>비동기 프로그램의 제어 흐름</title>
      <link>https://nolleh.github.io/csharp/async-control-flow-msdn/</link>
      <pubDate>Fri, 21 Dec 2018 22:02:13 +0900</pubDate>
      <guid>https://nolleh.github.io/csharp/async-control-flow-msdn/</guid>
      <description>개요 다음에서 발췌
비동기 프로그램의 제어 흐름
코드 public partial class MainWindow : Window { // . . . private async void startButton_Click(object sender, RoutedEventArgs e) { // ONE Task&amp;lt;int&amp;gt; getLengthTask = AccessTheWebAsync(); // FOUR int contentLength = await getLengthTask; // SIX resultsTextBox.Text += $&amp;#34;\r\nLength of the downloaded string: {contentLength}.\r\n&amp;#34;; } async Task&amp;lt;int&amp;gt; AccessTheWebAsync() { // TWO HttpClient client = new HttpClient(); Task&amp;lt;string&amp;gt; getStringTask = client.GetStringAsync(&amp;#34;https://msdn.microsoft.com&amp;#34;); // THREE string urlContents = await getStringTask; // FIVE return urlContents.</description>
    </item>
    <item>
      <title>Async Await 을 사용한 비동기 프로그래밍</title>
      <link>https://nolleh.github.io/csharp/async-await-msdn/</link>
      <pubDate>Fri, 21 Dec 2018 21:41:08 +0900</pubDate>
      <guid>https://nolleh.github.io/csharp/async-await-msdn/</guid>
      <description>개요 다음에서 발췌 MSDN
반응성을 향상시키는 비동기 잠재적인 차단 작업 완료 될때까지 다른 작업을 게속 수행
작성이 간편한 비동기 메서드 반환 형식은 다음 중 하나
Task Task void - 비동기 이벤트 처리기 작성 GetAwaiter 포함 모든 기타 형식 await 을 만나면 yield 함 (호출자로 제어가 돌아감) 이때, Task 가 호출자에게 반환되고 이는 언젠가 다운로드된 문자열의 길이가 반환된다는 약속 (future) 을 의미한다. await 전에 작업이 완료된다면 제어가 돌아가지 않는다. 스레드 비동기 메서드의 await 식은 대기한 작업이 실행되는 동안 현재 스레드를 차단하지 않는다.</description>
    </item>
    <item>
      <title>Dispose</title>
      <link>https://nolleh.github.io/csharp/dispose/</link>
      <pubDate>Wed, 19 Dec 2018 10:18:25 +0900</pubDate>
      <guid>https://nolleh.github.io/csharp/dispose/</guid>
      <description>Dispose 에 대한 여러가지 MSDN Implementing a Dispose method
threadSafety stackoverflow dispose 의 threadsafety
많은 경우 어떤 스레드든지 다른 스레드가 dispose 를 시작했을때 오브젝트에 대해 작업을 하고 있을 수 있기 때문에, interlocked.Exchange 를 통해 배제하는게 옳아 보인다.
물론, 좋은 생각이고 표준 dispose 패턴의 일부가 되어야 한다고 생각한다.
(champareExchange가 base class 에 봉인됨으로써 derived class 에서 private 한 disposed flag 를 사용하는 것을 피해야한다.)
하지만 불행히도, dispose 가 정확히 어떤것을 하는지 생각해보면 문제는 좀 더 복잡해진다.</description>
    </item>
    <item>
      <title>Async Await</title>
      <link>https://nolleh.github.io/csharp/async-await/</link>
      <pubDate>Tue, 18 Dec 2018 13:47:33 +0900</pubDate>
      <guid>https://nolleh.github.io/csharp/async-await/</guid>
      <description>NeoSmart.AsyncLock 라이브러리에 관하여 다음에서 발췌, 번역 - Neosmart Docs.
개요 semaporeslim 은 reentrance 를 지원하지 않는다. 따라서, recursion 에서 적절히 사용되지 않으면 데드락이 발생한다.
asynclock 은 reentrance 기능을 semaphoreslim 에 추가한거.
대안 간단한 방법은 semaphoreslim 으로 교체하고, recursion 인 경우를 스레드 아이디로 확인 하는 것.
이 경우의 문제는
async / await 의 가장 기본적인 목적인 ui 의 불필요한 블럭킹 없이 작업의 완료를 기다린다는 문제를 그대로 안고 있다.
await 코드를 넣어도 다른 코드가 실행 될 수 없다.</description>
    </item>
    <item>
      <title>Nancy Introduction</title>
      <link>https://nolleh.github.io/nancy/introduction/</link>
      <pubDate>Tue, 24 Apr 2018 21:43:04 +0900</pubDate>
      <guid>https://nolleh.github.io/nancy/introduction/</guid>
      <description>Nancy 에 대한 문서 번역 #1. By Nolleh
Introduction 가장 먼저, Nancy 의 세계에 온것을 환영합니다!
루비의 sinatra 프레임워크에 영감을 받아 Nancy 라는 이름을 붙이게 되었습니다. (Frank Sinatra 의 딸이름이 Nancy 니까요!)
NancyFx 의 Fx 에 대해 많은 사람들이 궁금해하여 여기에 붙입니다만, framework 라는 뜻입니다 :)
NancyFx 는 모든 컴포넌트들을 포함하는 umbrella project 입니다. (#역자주: 우산효과의 우산처럼, 포괄적인 프로젝트라는 의미로 쓴게 아닐까? )
이 가이드는 앞으로 개괄적이고 빠르게 Nancy 의 특징들을 살펴 독자 스스로 Nancy 의 세계를 탐험해 볼 수 있는 시야를 제공할겁니다.</description>
    </item>
    <item>
      <title>Unix 01 Intro</title>
      <link>https://nolleh.github.io/network/unix-01-intro/</link>
      <pubDate>Tue, 01 Aug 2017 22:54:19 +0900</pubDate>
      <guid>https://nolleh.github.io/network/unix-01-intro/</guid>
      <description>네트워킹의 바이블이라 할 수 있는 Unix Network Programming 의 내용 정리
Books Introduction Socket 을 통해 통신하는 프로그램을 작성하는 개발자를 위해 쓰여진 책.
시작하는 사람에게나, 프로페셔널에게나 유용한 책.
물론 유지보수를 하거나, 새로 작성하는 사람, 네트워크 시스템 함수를 이해하는 모두에게 유용하다.
실제 텍스트들은 유닉스 시스템에서 구동가능하나, OS 에 독립적인 socket api 를 지원하는 다른 OS 에서도, 본문에서 제안하는 일반적인 개념을 활용가능하다.
많은 OS 는 셀수 없이 많은 네트워크 응용프로그램을 제공하고 있으며 - 예컨데 웹브라우저, email.</description>
    </item>
    <item>
      <title>스프링 기본 용어/정리</title>
      <link>https://nolleh.github.io/web/fund-spring/</link>
      <pubDate>Wed, 26 Jul 2017 23:11:14 +0900</pubDate>
      <guid>https://nolleh.github.io/web/fund-spring/</guid>
      <description>어쩌다보니 그동안 손댈 일이 없던 웹서버에 좀 손을 대게 되서 (게임서버, 클라이언트, 그리고 웹서버..정녕 풀스택 개발자가 되는것인가..ㅋ), 예전 선배님이 버리고 간(?) 스프링 책을 꺼내서 읽어 보며 정리한 내용이므로 본 글을 처음 접한 사람이 이해하기에 많은 내용을 담지 않을 수 있음.
Spring Bean 객체 스프링에서 생성하여 관리하여 주는 스프링 빈 객체 혹은 빈 객체라고 부른다. res/applicationContext.xml 에 태그로 선언할 수도 있다. 이렇게 선언한경우, 리플렉션을 활용하여 bean id 클래스의 인스턴스를 지정한 세부 태그의 속성으로 메서드를 호출하여 객체를 초기화한다.</description>
    </item>
    <item>
      <title>파일 버퍼링</title>
      <link>https://nolleh.github.io/operating-system/file-buffering/</link>
      <pubDate>Mon, 17 Jul 2017 00:25:28 +0900</pubDate>
      <guid>https://nolleh.github.io/operating-system/file-buffering/</guid>
      <description>다음에서 발췌, 번역
https://msdn.microsoft.com/en-gb/library/windows/desktop/cc644950(v=vs.85).aspx File Buffering 파일버퍼링 - unbuffered file I/O.
본문에선 시스템에 의해 캐싱되지 않는 (buffered) 데이터를
어떻게 유저 모드의 응용프로그램에서 데이터를 활용할 수 (interact) 있을지에 대해 다룬다.
FILE_FLAG_NO_BUFFERING 플래그를 통해 CreateFile 을 Open 하면,
파일을 읽거나 쓸때 시스템의 캐싱을 비활성화 하도록 제어할 수 있다.
I/O 버퍼링을 사용한것과 같은 효과를 내려면, 데이터 alignment 가 반드시 고려되어야 한다.
Note 파일에 대해 Seeking 과 위치포인터, offsets 의 개념을 사용하는 파일에 대해 alignment 정보가 고려될 필요가 있다.</description>
    </item>
    <item>
      <title>Concurrent Idiom 1 - Stack</title>
      <link>https://nolleh.github.io/concurrency/concurrent-idiom-1-stack/</link>
      <pubDate>Mon, 10 Jul 2017 22:57:57 +0900</pubDate>
      <guid>https://nolleh.github.io/concurrency/concurrent-idiom-1-stack/</guid>
      <description>concurrent 프로그램을 작성할 때 고려해야할 몇가지 사항. 그리고 idiom.
여러 서적에서 발췌하였으며, 정리 차원에서 작성한 내용이므로 본 글을 처음 접한 사람이 이해하기에 많은 내용을 담지 않을 수 있음.
어쩌면 작성자의 부사수를 위한 자재가 될지도 모르겠&amp;hellip;(..)
Concurrent ISSUE - Stack 이번엔 스택.
if (!s.empty()) { item = s.top(); s.pop(); } 인터페이스상의 문제이기 때문에 empty 와 top 사이의 safety 를 보장할 수 없다.
top() / pop() 도 마찬가지 -&amp;raquo; 조회되지 못하는 아이템이 있을 수 있다.</description>
    </item>
    <item>
      <title>How To Make Git Page</title>
      <link>https://nolleh.github.io/env/how-to-make-git-page/</link>
      <pubDate>Fri, 07 Jul 2017 21:22:50 +0900</pubDate>
      <guid>https://nolleh.github.io/env/how-to-make-git-page/</guid>
      <description>Making Git Page</description>
    </item>
    <item>
      <title>Brew Install 이 구버전만 설치할 때</title>
      <link>https://nolleh.github.io/env/brew-update/</link>
      <pubDate>Tue, 04 Jul 2017 22:31:23 +0900</pubDate>
      <guid>https://nolleh.github.io/env/brew-update/</guid>
      <description>개발 환경 - Brew</description>
    </item>
    <item>
      <title>markDown 문법</title>
      <link>https://nolleh.github.io/env/mark-down-syntax/</link>
      <pubDate>Tue, 04 Jul 2017 22:13:52 +0900</pubDate>
      <guid>https://nolleh.github.io/env/mark-down-syntax/</guid>
      <description>mark down 문법</description>
    </item>
    <item>
      <title>C&#43;&#43; CLI 에서 managed 콜백을 unmanaged 로 전달하기</title>
      <link>https://nolleh.github.io/etc/managed_cb_to_unmanaged/</link>
      <pubDate>Tue, 04 Jul 2017 00:45:55 +0900</pubDate>
      <guid>https://nolleh.github.io/etc/managed_cb_to_unmanaged/</guid>
      <description>파라미터가 없다면 DelegateToPointer 로 마샬링해서 전달하면되는데,
이러면 파라미터를 마샬링할 기회가 주어지지 않는다는게 문제다.
좀 구글링을 해봤는데,
이런 포스트가 있었다.
스택오버플로-파라미터와 함께 unmanaged 콜백으로 변환하기
채택된 답변을 살펴보면 클래스 구조는 대략 다음과 같다.
클래스 구조 NativeCallbackHandler - msclr::gcroot&amp;lt;OutputManaged^&amp;gt; m_owner (OutputLogManaged) 를 멤버로 보유. OutputLogManaged - native OutputLog* (m_nativeOutputLog) / 1의 Holder 를 보유 (m_nativeHandler)] / 그리고 managed 콜백을 보유 OutputLog - Native Callback 과 void* UserData 를 멤버로 보유. 이해하는데 주요한 클래스는 위 내용 정도인 듯.</description>
    </item>
  </channel>
</rss>
