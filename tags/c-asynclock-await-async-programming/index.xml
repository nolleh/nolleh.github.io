<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# Asynclock Await Async Programming on The Computer Programmer, Nolleh</title>
    <link>https://nolleh.github.io/tags/c-asynclock-await-async-programming/</link>
    <description>Recent content in C# Asynclock Await Async Programming on The Computer Programmer, Nolleh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>nolleh7707@gmail.com (nolleh)</managingEditor>
    <webMaster>nolleh7707@gmail.com (nolleh)</webMaster>
    <lastBuildDate>Tue, 18 Dec 2018 11:08:53 +0900</lastBuildDate>
    
	<atom:link href="https://nolleh.github.io/tags/c-asynclock-await-async-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Async Await</title>
      <link>https://nolleh.github.io/c#/async-await/</link>
      <pubDate>Tue, 18 Dec 2018 11:08:53 +0900</pubDate>
      <author>nolleh7707@gmail.com (nolleh)</author>
      <guid>https://nolleh.github.io/c#/async-await/</guid>
      <description>NeoSmart.AsyncLock 라이브러리에 관하여  다음에서 발췌, 번역 - Neosmart Docs.
 개요 semaporeslim 은 reentrance 를 지원하지 않는다. 따라서, recursion 에서 적절히 사용되지 않으면 데드락이 발생한다.
asynclock 은 reentrance 기능을 semaphoreslim 에 추가한거.
대안 간단한 방법은 semaphoreslim 으로 교체하고, recursion 인 경우를 스레드 아이디로 확인 하는 것.
이 경우의 문제는
async / await 의 가장 기본적인 목적인 ui 의 불필요한 블럭킹 없이 작업의 완료를 기다린다는 문제를 그대로 안고 있다.</description>
    </item>
    
  </channel>
</rss>